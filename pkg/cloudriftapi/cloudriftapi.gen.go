// Package cloudriftapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package cloudriftapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	Api_keyScopes     = "api_key.Scopes"
	Bearer_authScopes = "bearer_auth.Scopes"
	TokenScopes       = "token.Scopes"
)

// Defines values for AccountSelector0.
const (
	ByToken AccountSelector0 = "ByToken"
)

// Defines values for ApiKeySelector2.
const (
	ApiKeySelector2All ApiKeySelector2 = "All"
)

// Defines values for ComputeProviderSelector0.
const (
	ComputeProviderSelector0All ComputeProviderSelector0 = "All"
)

// Defines values for DiskKind.
const (
	HDD     DiskKind = "HDD"
	SSD     DiskKind = "SSD"
	Unknown DiskKind = "Unknown"
)

// Defines values for InstanceMode.
const (
	BareMetal      InstanceMode = "BareMetal"
	Container      InstanceMode = "Container"
	VirtualMachine InstanceMode = "VirtualMachine"
)

// Defines values for InstanceStatus.
const (
	Active       InstanceStatus = "Active"
	Deactivating InstanceStatus = "Deactivating"
	Inactive     InstanceStatus = "Inactive"
	Initializing InstanceStatus = "Initializing"
)

// Defines values for InstanceTypeSelector0.
const (
	InstanceTypeSelector0All InstanceTypeSelector0 = "All"
)

// Defines values for KeyStatus.
const (
	KeyStatusError   KeyStatus = "error"
	KeyStatusSuccess KeyStatus = "success"
)

// Defines values for NodeStatus.
const (
	Hibernated    NodeStatus = "Hibernated"
	NotResponding NodeStatus = "NotResponding"
	Offline       NodeStatus = "Offline"
	Ready         NodeStatus = "Ready"
)

// Defines values for ReservationSelector0.
const (
	ReservationSelector0All ReservationSelector0 = "All"
)

// Defines values for ResponseStatus.
const (
	ResponseStatusError          ResponseStatus = "error"
	ResponseStatusPartialSuccess ResponseStatus = "partial_success"
	ResponseStatusSuccess        ResponseStatus = "success"
)

// Defines values for SshKeySelector1.
const (
	All SshKeySelector1 = "All"
)

// Defines values for TeamRole.
const (
	Admin  TeamRole = "Admin"
	Member TeamRole = "Member"
	Owner  TeamRole = "Owner"
)

// AccountInfoProto defines model for AccountInfoProto.
type AccountInfoProto struct {
	Data struct {
		// Balance Amount of money in currency units (cents)
		Balance int64 `json:"balance"`

		// CurrentCostPerHour Current cost per hour in currency units (cents)
		CurrentCostPerHour *float64 `json:"current_cost_per_hour"`

		// DisputeFees Dispute fees that are charged by the payment processor
		DisputeFees int64 `json:"dispute_fees"`

		// Disputed Disputed amount, i.e. the amount that is disputed by the user and thus frozen
		Disputed int64 `json:"disputed"`

		// Pending Amount of money pending to be credited/debited
		Pending float64 `json:"pending"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// AccountSelector defines model for AccountSelector.
type AccountSelector struct {
	union json.RawMessage
}

// AccountSelector0 defines model for AccountSelector.0.
type AccountSelector0 string

// AccountSelector1 defines model for .
type AccountSelector1 struct {
	ByTeam string `json:"ByTeam"`
}

// AddApiKeyRequestProto defines model for AddApiKeyRequestProto.
type AddApiKeyRequestProto struct {
	Data struct {
		// Active Enable/disable API key
		Active bool `json:"active"`

		// Name API key name
		Name *string `json:"name"`

		// TeamId Team ID in case of a team API key
		TeamId *string `json:"team_id"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// AddApiKeyResponseProto defines model for AddApiKeyResponseProto.
type AddApiKeyResponseProto struct {
	Data struct {
		// Active Enabled/disabled status
		Active bool `json:"active"`

		// Id API key ID
		Id string `json:"id"`

		// Key API key value, only available at generation time
		Key string `json:"key"`

		// Name API key name
		Name *string `json:"name"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// AddNetworkRequestProto defines model for AddNetworkRequestProto.
type AddNetworkRequestProto struct {
	Data struct {
		// Datacenter Datacenter for the network
		Datacenter string `json:"datacenter"`

		// Gateway Gateway IP address
		Gateway string `json:"gateway"`

		// Iface Optional network interface name
		Iface *string `json:"iface"`

		// IpRanges IP ranges to add to the network
		IpRanges []NetworkIpRange `json:"ip_ranges"`

		// Name Network name
		Name string `json:"name"`

		// Netmask Optional network mask
		Netmask *int32 `json:"netmask"`

		// ServerAddress Optional server address if need to use internal IP for communication
		ServerAddress *string `json:"server_address"`

		// TeamId Optional team ID
		TeamId *string `json:"team_id"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// AddNetworkResponseProto defines model for AddNetworkResponseProto.
type AddNetworkResponseProto struct {
	Data struct {
		// Id ID of the created network
		Id string `json:"id"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// AddSshKeyRequestProto defines model for AddSshKeyRequestProto.
type AddSshKeyRequestProto struct {
	Data struct {
		// Name SSH key name
		Name string `json:"name"`

		// PublicKey SSH key public part
		PublicKey *string `json:"public_key"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// AddTeamMemberRequestProto defines model for AddTeamMemberRequestProto.
type AddTeamMemberRequestProto struct {
	Data struct {
		Email string    `json:"email"`
		Role  *TeamRole `json:"role,omitempty"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ApiKey TODO: Currently we have user API keys and provider API keys
//
//	This protocol handles only user API keys as provider API keys are planned for removal
type ApiKey struct {
	// Active Enabled/disabled status
	Active bool `json:"active"`

	// CreatedAt API key creation time
	CreatedAt string `json:"created_at"`

	// CreatorEmail The email of the creator of the API key in case of team API keys
	CreatorEmail *string `json:"creator_email"`

	// CreatorName The name of the creator of the API key in case of team API keys
	CreatorName *string `json:"creator_name"`

	// HasSecret Whether the API key has a secret part
	HasSecret bool `json:"has_secret"`

	// Id API key ID
	Id string `json:"id"`

	// Key Public part of the API key
	Key string `json:"key"`

	// Name API key name
	Name *string `json:"name"`
}

// ApiKeySelector defines model for ApiKeySelector.
type ApiKeySelector struct {
	union json.RawMessage
}

// ApiKeySelector0 defines model for .
type ApiKeySelector0 struct {
	ByTeamId string `json:"ByTeamId"`
}

// ApiKeySelector1 defines model for .
type ApiKeySelector1 struct {
	ById []string `json:"ById"`
}

// ApiKeySelector2 defines model for ApiKeySelector.2.
type ApiKeySelector2 string

// BulkServiceChargeRequestProto defines model for BulkServiceChargeRequestProto.
type BulkServiceChargeRequestProto struct {
	Data struct {
		// Charges Charges to be applied
		Charges []ServiceCharge `json:"charges"`

		// Provider Name of the provider of the service
		Provider string `json:"provider"`

		// Service Name of the service to charge
		Service string `json:"service"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// BulkServiceChargeResponseProto defines model for BulkServiceChargeResponseProto.
type BulkServiceChargeResponseProto struct {
	Data struct {
		// RequestIds Either a provided request IDs or generated ones
		RequestIds []string `json:"request_ids"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ComputeProviderInfo defines model for ComputeProviderInfo.
type ComputeProviderInfo struct {
	// Datacenters Data centers where the provider has resources
	Datacenters []DataCenterInfo `json:"datacenters"`

	// Description Description of the provider
	Description *string `json:"description"`

	// Email Provider email address
	Email *string `json:"email"`

	// ListOnMarketplace Whether the provider should be listed on the marketplace
	ListOnMarketplace bool `json:"list_on_marketplace"`

	// LogoUrl Provider logo URL
	LogoUrl *string `json:"logo_url"`

	// Name Provider name (unique ID)
	Name string `json:"name"`

	// Website Provider website URL
	Website *string `json:"website"`
}

// ComputeProviderSelector defines model for ComputeProviderSelector.
type ComputeProviderSelector struct {
	union json.RawMessage
}

// ComputeProviderSelector0 Select all providers
type ComputeProviderSelector0 string

// ComputeProviderSelector1 Select providers by name
type ComputeProviderSelector1 struct {
	// ByName Select providers by name
	ByName []string `json:"ByName"`
}

// CpuInfo defines model for CpuInfo.
type CpuInfo struct {
	// Brand Full brand name of the CPU
	Brand string `json:"brand"`

	// BrandShort Short and recognizable brand name of the CPU
	BrandShort string `json:"brand_short"`

	// LogicalCoreCount Number of logical cores
	LogicalCoreCount int32 `json:"logical_core_count"`

	// PhysicalCoreCount Number of physical cores
	PhysicalCoreCount int32 `json:"physical_core_count"`

	// Vendor Vendor of the CPU
	Vendor *string `json:"vendor"`

	// VendorLogoUrl Logo of the CPU vendor
	VendorLogoUrl *string `json:"vendor_logo_url"`
}

// CreateTeamRequestProto defines model for CreateTeamRequestProto.
type CreateTeamRequestProto struct {
	Data struct {
		Description *string `json:"description"`
		Name        string  `json:"name"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// CreateTeamResponseProto defines model for CreateTeamResponseProto.
type CreateTeamResponseProto struct {
	Data struct {
		AccountId   string  `json:"account_id"`
		CreatedAt   string  `json:"created_at"`
		Description *string `json:"description"`
		Id          string  `json:"id"`
		Name        string  `json:"name"`
		UpdatedAt   string  `json:"updated_at"`
		UserRole    string  `json:"user_role"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// DataCenterInfo defines model for DataCenterInfo.
type DataCenterInfo struct {
	// CountryCode Data center country code
	CountryCode *string `json:"country_code"`

	// Location Data center geographical location
	Location []interface{} `json:"location"`

	// Name Data center name like 'us-east-nc-nr-1' (unique ID)
	Name string `json:"name"`
}

// DatacenterNetworks defines model for DatacenterNetworks.
type DatacenterNetworks struct {
	Datacenter string   `json:"datacenter"`
	Networks   []string `json:"networks"`
}

// DeleteApiKeysRequestProto defines model for DeleteApiKeysRequestProto.
type DeleteApiKeysRequestProto struct {
	Data struct {
		Selector ApiKeySelector `json:"selector"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// DeleteApiKeysResponseProto defines model for DeleteApiKeysResponseProto.
type DeleteApiKeysResponseProto struct {
	Data struct {
		// Keys Information about the deleted API keys with their operation status
		Keys   []KeyResult    `json:"keys"`
		Status ResponseStatus `json:"status"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// DeleteSshKeyRequestProto defines model for DeleteSshKeyRequestProto.
type DeleteSshKeyRequestProto struct {
	Data struct {
		Selector SshKeySelector `json:"selector"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// DiskInfo defines model for DiskInfo.
type DiskInfo struct {
	// FsType File system type like ext4, xfs
	FsType string   `json:"fs_type"`
	Kind   DiskKind `json:"kind"`

	// MountPoint Mount point of the disk like /
	MountPoint string `json:"mount_point"`

	// Name Disk name like sda, nvme0n1
	Name string `json:"name"`

	// Size Total disk size in bytes
	Size int64 `json:"size"`
}

// DiskKind defines model for DiskKind.
type DiskKind string

// DockerRegistryAuth defines model for DockerRegistryAuth.
type DockerRegistryAuth struct {
	union json.RawMessage
}

// DockerRegistryAuth0 defines model for .
type DockerRegistryAuth0 struct {
	UsernamePassword struct {
		Password string `json:"password"`
		Username string `json:"username"`
	} `json:"UsernamePassword"`
}

// ExternalTransactionRequestProto defines model for ExternalTransactionRequestProto.
type ExternalTransactionRequestProto struct {
	Data struct {
		Account AccountSelector `json:"account"`

		// Amount Amount of money in currency units (cents)
		Amount int64 `json:"amount"`

		// Description Description of the payout
		Description *string `json:"description"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// GenerateSshKeyResponseProto defines model for GenerateSshKeyResponseProto.
type GenerateSshKeyResponseProto struct {
	Data struct {
		// PrivateKey SSH key private part in PEM format (base64 encoded)
		PrivateKey []int32 `json:"private_key"`
		PublicKey  SshKey  `json:"public_key"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// GpuInfo defines model for GpuInfo.
type GpuInfo struct {
	// Brand Full brand name of the GPU
	Brand *string `json:"brand"`

	// BrandShort Short and recognizable brand name of the GPU
	BrandShort *string `json:"brand_short"`

	// PciDeviceId PCI device ID, it can be used to locate GPU model if high-level information is not available
	PciDeviceId int32 `json:"pci_device_id"`

	// PciSlot PCI slot information
	PciSlot *string `json:"pci_slot"`

	// PciVendorId PCI vendor ID, it can be used to locate GPU model if high-level information is not available
	PciVendorId int32 `json:"pci_vendor_id"`

	// Vendor Vendor of the GPU
	Vendor *string `json:"vendor"`

	// VendorLogoUrl Logo of the GPU vendor
	VendorLogoUrl *string `json:"vendor_logo_url"`

	// Vram Amount of memory in bytes
	Vram int64 `json:"vram"`
}

// InstanceAndUsageInfo defines model for InstanceAndUsageInfo.
type InstanceAndUsageInfo struct {
	BareMetal *InstanceBareMetalInfo `json:"bare_metal,omitempty"`

	// Containers Containers running on this instance
	Containers []InstanceContainerInfo `json:"containers"`
	Cpu        *CpuInfo                `json:"cpu,omitempty"`

	// CpuLimit Number of CPUs available to the instance
	CpuLimit *int32 `json:"cpu_limit"`

	// CpuMask CPUs available to instance as a hex number making a bitmask
	CpuMask *string `json:"cpu_mask"`

	// DiskLimit GPU information on the instance node
	// maximum amount of disk space
	DiskLimit *int64 `json:"disk_limit"`

	// Dram Information about memory on the node
	Dram *int64 `json:"dram"`

	// DramLimit Maximum amount of DRAM available to the instance
	DramLimit *int64 `json:"dram_limit"`

	// GpuLimit number of GPUs available to the instance
	GpuLimit *int32 `json:"gpu_limit"`

	// GpuMask gpus available to instance as a hex number making a bitmask
	GpuMask *string `json:"gpu_mask"`

	// Gpus GPU models like GeForce RTX 4090
	Gpus *[]GpuInfo `json:"gpus"`

	// HostAddress instance public IP address (external IP when available, internal IP otherwise)
	HostAddress *string `json:"host_address"`

	// Id ID of the instance to be used in API calls
	Id           string                    `json:"id"`
	Instructions *InstanceUserInstructions `json:"instructions,omitempty"`

	// InternalHostAddress instance internal IP address (for implementation details)
	InternalHostAddress *string `json:"internal_host_address"`

	// NodeId ID of the node the instance is running on
	NodeId          string                `json:"node_id"`
	NodeMode        InstanceMode          `json:"node_mode"`
	NodeStatus      NodeStatus            `json:"node_status"`
	ReservationData *ReservationDates     `json:"reservation_data,omitempty"`
	ResourceInfo    *InstanceResourceInfo `json:"resource_info,omitempty"`
	Status          InstanceStatus        `json:"status"`
	UsageInfo       *InstanceUsageInfo    `json:"usage_info,omitempty"`

	// VirtualMachines Virtual machines running on this instance
	VirtualMachines []InstanceVirtualMachineInfo `json:"virtual_machines"`
}

// InstanceBareMetalInfo defines model for InstanceBareMetalInfo.
type InstanceBareMetalInfo struct {
	LoginInfo *InstanceLoginInfo `json:"login_info,omitempty"`
	Name      string             `json:"name"`
	Ready     bool               `json:"ready"`
}

// InstanceConfiguration defines model for InstanceConfiguration.
type InstanceConfiguration struct {
	union json.RawMessage
}

// InstanceConfiguration0 defines model for .
type InstanceConfiguration0 struct {
	BareMetal struct {
		SshKey InstanceSshKeySelector `json:"ssh_key"`
	} `json:"BareMetal"`
}

// InstanceConfiguration1 defines model for .
type InstanceConfiguration1 struct {
	VirtualMachine struct {
		// CloudinitCommands Command to run in the VM
		CloudinitCommands *string `json:"cloudinit_commands"`

		// CloudinitUrl Cloud-init configuration file content
		CloudinitUrl *string `json:"cloudinit_url"`

		// ImageUrl ULR of the image to use for the VM
		ImageUrl string                  `json:"image_url"`
		SshKey   *InstanceSshKeySelector `json:"ssh_key,omitempty"`
	} `json:"VirtualMachine"`
}

// InstanceConfiguration2 defines model for .
type InstanceConfiguration2 struct {
	Docker struct {
		// Command Command to run in the container
		Command *[]string `json:"command"`

		// Env Environment variables to set
		Env *[][]interface{} `json:"env"`

		// Image Docker image to run
		Image *string `json:"image"`

		// Name Optional name for the container
		Name *string `json:"name"`

		// Ports Ports to expose in the format <host>:<container>/<tcp|udp|sctp>
		Ports        *[]string           `json:"ports"`
		RegistryAuth *DockerRegistryAuth `json:"registry_auth,omitempty"`
	} `json:"Docker"`
}

// InstanceContainerInfo defines model for InstanceContainerInfo.
type InstanceContainerInfo struct {
	DockerId          string  `json:"docker_id"`
	Name              *string `json:"name"`
	TruncatedDockerId string  `json:"truncated_docker_id"`
}

// InstanceInfo defines model for InstanceInfo.
type InstanceInfo struct {
	// CostPerHour Cost per hour in currency units (cents)
	CostPerHour int32 `json:"cost_per_hour"`

	// Name Instance type name
	Name string `json:"name"`
}

// InstanceLoginInfo defines model for InstanceLoginInfo.
type InstanceLoginInfo struct {
	union json.RawMessage
}

// InstanceLoginInfo0 defines model for .
type InstanceLoginInfo0 struct {
	UsernameAndPassword struct {
		Password string `json:"password"`
		Username string `json:"username"`
	} `json:"UsernameAndPassword"`
}

// InstanceLoginInfo1 defines model for .
type InstanceLoginInfo1 struct {
	Username struct {
		Username string `json:"username"`
	} `json:"Username"`
}

// InstanceMode defines model for InstanceMode.
type InstanceMode string

// InstanceResourceInfo defines model for InstanceResourceInfo.
type InstanceResourceInfo struct {
	// CostPerHour Cost per hour in currency units
	CostPerHour float32 `json:"cost_per_hour"`

	// InstanceType Name of the instance type
	InstanceType string `json:"instance_type"`

	// ProviderName Name of the provider, i.e. resource owner
	ProviderName string `json:"provider_name"`
}

// InstanceSshKeySelector defines model for InstanceSshKeySelector.
type InstanceSshKeySelector struct {
	union json.RawMessage
}

// InstanceSshKeySelector0 List of SSH key names to use for the instance
type InstanceSshKeySelector0 struct {
	// ByName List of SSH key names to use for the instance
	ByName []string `json:"ByName"`
}

// InstanceSshKeySelector1 Use specified SSH key
type InstanceSshKeySelector1 struct {
	// PublicKeys Use specified SSH key
	PublicKeys []string `json:"PublicKeys"`
}

// InstanceSshKeySelector2 defines model for .
type InstanceSshKeySelector2 struct {
	ById []string `json:"ById"`
}

// InstanceStatus defines model for InstanceStatus.
type InstanceStatus string

// InstanceType defines model for InstanceType.
type InstanceType struct {
	// BrandShort Short and recognizable brand name of the core instance hardware for easier navigation
	BrandShort *string `json:"brand_short"`

	// Manufacturer Used to display GPU or CPU (if no GPU is present) vendor to the user for easier navigation
	Manufacturer *string `json:"manufacturer"`

	// Name Instance type name
	Name string `json:"name"`

	// Variants List of variants of the Instance Type
	Variants []InstanceVariantInfo `json:"variants"`
}

// InstanceTypeSelector defines model for InstanceTypeSelector.
type InstanceTypeSelector struct {
	union json.RawMessage
}

// InstanceTypeSelector0 Select all instance types
type InstanceTypeSelector0 string

// InstanceTypeSelector1 Select instance types by service name
type InstanceTypeSelector1 struct {
	// ByServiceAndLocation Select instance types by service name
	ByServiceAndLocation struct {
		// Datacenters Locations of the instance types
		Datacenters *[]string `json:"datacenters"`

		// Services List of services that the instance type should support, e.g. docker, VM
		Services *[]string `json:"services"`
	} `json:"ByServiceAndLocation"`
}

// InstanceTypeSelector2 Select instance types by service and provider name
type InstanceTypeSelector2 struct {
	// ByServiceAndProvider Select instance types by service and provider name
	ByServiceAndProvider struct {
		// Providers List of providers that the instance type should support, e.g. AWS, GCP
		Providers *[]string `json:"providers"`

		// Services List of services that the instance type should support, e.g. docker, VM
		Services *[]string `json:"services"`
	} `json:"ByServiceAndProvider"`
}

// InstanceTypeSelector3 Select instance types by name
type InstanceTypeSelector3 struct {
	// ByName Select instance types by name
	ByName []string `json:"ByName"`
}

// InstanceUsageInfo defines model for InstanceUsageInfo.
type InstanceUsageInfo struct {
	// AccountedUsage Amount of usage we've subtracted from user balance
	AccountedUsage map[string]int32 `json:"accounted_usage"`

	// Usage Total amount of usage we've estimated
	Usage map[string]int32 `json:"usage"`

	// UserEmail User's email of the instance
	UserEmail string `json:"user_email"`

	// UserName User's name of the instance
	UserName string `json:"user_name"`
}

// InstanceUserInstructions defines model for InstanceUserInstructions.
type InstanceUserInstructions struct {
	// InstructionsTemplate Instructions for the user to access the instance, stored as base64-encoded bytes
	InstructionsTemplate string `json:"instructions_template"`

	// PlaceholderValues Placeholder values for the instructions template
	PlaceholderValues [][]interface{} `json:"placeholder_values"`
}

// InstanceVariant defines model for InstanceVariant.
type InstanceVariant struct {
	// CpuCount CPU count
	CpuCount int32 `json:"cpu_count"`

	// Disk Disk size in bytes
	Disk int64 `json:"disk"`

	// Dram RAM size
	Dram int64 `json:"dram"`

	// GpuCount GPU count
	GpuCount *int32 `json:"gpu_count"`

	// Name Instance variant name including instance type name
	Name string `json:"name"`

	// Vram VRAM per GPU
	Vram int64 `json:"vram"`
}

// InstanceVariantInfo defines model for InstanceVariantInfo.
type InstanceVariantInfo struct {
	// AvailableNodes Number of nodes that this variant is available on to estimate availability
	AvailableNodes int32 `json:"available_nodes"`

	// AvailableNodesPerDc Number of nodes that this variant is available on per datacenter
	AvailableNodesPerDc map[string]int32 `json:"available_nodes_per_dc"`

	// CostPerHour Cost of the instance per hour in currency units (cents)
	CostPerHour float64 `json:"cost_per_hour"`

	// CpuCount CPU count
	CpuCount int32 `json:"cpu_count"`

	// Disk Disk size in bytes
	Disk int64 `json:"disk"`

	// Dram RAM size
	Dram int64 `json:"dram"`

	// GpuCount GPU count
	GpuCount *int32 `json:"gpu_count"`

	// LogicalCpuCount Logical CPU count (cpu_count * 2)
	LogicalCpuCount int32 `json:"logical_cpu_count"`

	// Name Instance variant name including instance type name
	Name string `json:"name"`

	// Nodes Number of nodes that this variant is available on to estimate availability
	Nodes int32 `json:"nodes"`

	// NodesPerDc Number of nodes that this variant is available on per datacenter
	NodesPerDc map[string]int32 `json:"nodes_per_dc"`

	// Vram VRAM per GPU
	Vram int64 `json:"vram"`
}

// InstanceVirtualMachineInfo defines model for InstanceVirtualMachineInfo.
type InstanceVirtualMachineInfo struct {
	LoginInfo *InstanceLoginInfo `json:"login_info,omitempty"`
	Name      string             `json:"name"`
	Ready     bool               `json:"ready"`
	Vmid      int32              `json:"vmid"`
}

// InstancesSelector defines model for InstancesSelector.
type InstancesSelector struct {
	union json.RawMessage
}

// InstancesSelector0 List of instance IDs to retrieve information about
type InstancesSelector0 struct {
	// ById List of instance IDs to retrieve information about
	ById []string `json:"ById"`
}

// InstancesSelector1 Retrieve information about active/activating/deactivating/inactive user instances
type InstancesSelector1 struct {
	// ByStatus Retrieve information about active/activating/deactivating/inactive user instances
	ByStatus []InstanceStatus `json:"ByStatus"`
}

// InstancesSelector2 defines model for .
type InstancesSelector2 struct {
	ByTeamId string `json:"ByTeamId"`
}

// KeyError defines model for KeyError.
type KeyError struct {
	// Code Error code
	Code string `json:"code"`

	// Message Error message
	Message string `json:"message"`
}

// KeyResult defines model for KeyResult.
type KeyResult struct {
	Error *KeyError `json:"error,omitempty"`

	// Id API key ID
	Id     string    `json:"id"`
	Status KeyStatus `json:"status"`
}

// KeyStatus defines model for KeyStatus.
type KeyStatus string

// ListApiKeysRequestProto defines model for ListApiKeysRequestProto.
type ListApiKeysRequestProto struct {
	Data struct {
		Selector ApiKeySelector `json:"selector"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListApiKeysResponseProto defines model for ListApiKeysResponseProto.
type ListApiKeysResponseProto struct {
	Data struct {
		// Keys List of the user API keys
		Keys []ApiKey `json:"keys"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListInstanceTypesRequestProto defines model for ListInstanceTypesRequestProto.
type ListInstanceTypesRequestProto struct {
	Data struct {
		Selector *InstanceTypeSelector `json:"selector,omitempty"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListInstanceTypesResponseProto defines model for ListInstanceTypesResponseProto.
type ListInstanceTypesResponseProto struct {
	Data struct {
		// InstanceTypes List of the instance types available for renting
		InstanceTypes []InstanceType `json:"instance_types"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListInstancesRequestProto defines model for ListInstancesRequestProto.
type ListInstancesRequestProto struct {
	Data struct {
		Selector InstancesSelector `json:"selector"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListInstancesResponseProto defines model for ListInstancesResponseProto.
type ListInstancesResponseProto struct {
	Data struct {
		// Instances List of requested user instances, it might not contain all requested instances if some are not found or there was an error
		Instances []InstanceAndUsageInfo `json:"instances"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListIpRangesRequestProto defines model for ListIpRangesRequestProto.
type ListIpRangesRequestProto struct {
	Data struct {
		// Selector Which IP ranges to retrieve
		Selector interface{} `json:"selector"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListIpRangesResponseProto defines model for ListIpRangesResponseProto.
type ListIpRangesResponseProto struct {
	Data struct {
		// Ranges All IPs available for allocation
		Ranges []NetworkIpRanges `json:"ranges"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListNetworksRequestProto defines model for ListNetworksRequestProto.
type ListNetworksRequestProto struct {
	Data struct {
		Selector NetworkSelector `json:"selector"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListNetworksResponseProto defines model for ListNetworksResponseProto.
type ListNetworksResponseProto struct {
	Data struct {
		// DatacenterNetworks All Networks for the datacenter
		DatacenterNetworks []DatacenterNetworks `json:"datacenter_networks"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListProviderNodesRequestProto defines model for ListProviderNodesRequestProto.
type ListProviderNodesRequestProto struct {
	Data struct {
		// Selector Selector for filtering providers whose nodes to list
		Selector *interface{} `json:"selector,omitempty"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListProviderNodesResponseProto defines model for ListProviderNodesResponseProto.
type ListProviderNodesResponseProto struct {
	Data struct {
		// Nodes List of the nodes available for renting
		Nodes []ProviderNodeInfo `json:"nodes"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListProvidersRequestProto defines model for ListProvidersRequestProto.
type ListProvidersRequestProto struct {
	Data struct {
		Selector *ComputeProviderSelector `json:"selector,omitempty"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListProvidersResponseProto defines model for ListProvidersResponseProto.
type ListProvidersResponseProto struct {
	Data struct {
		// Providers List of compute providers on the platform
		Providers []ComputeProviderInfo `json:"providers"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListRecipesResponseProto defines model for ListRecipesResponseProto.
type ListRecipesResponseProto struct {
	Data struct {
		// Groups List of the recipe groups available for renting
		Groups []RecipeGroup `json:"groups"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListReservationTypesResponseProto defines model for ListReservationTypesResponseProto.
type ListReservationTypesResponseProto struct {
	Data struct {
		ReservationTypes []ReservationType `json:"reservation_types"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListReservationsRequestProto defines model for ListReservationsRequestProto.
type ListReservationsRequestProto struct {
	Data struct {
		Selector *ReservationSelector `json:"selector,omitempty"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListReservationsResponseProto defines model for ListReservationsResponseProto.
type ListReservationsResponseProto struct {
	Data struct {
		Reservations []Reservation `json:"reservations"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListSshKeysResponseProto defines model for ListSshKeysResponseProto.
type ListSshKeysResponseProto struct {
	Data struct {
		// Keys List of the SSH keys available for renting
		Keys []SshKey `json:"keys"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ListTeamsResponseProto defines model for ListTeamsResponseProto.
type ListTeamsResponseProto struct {
	Data struct {
		Teams []Team `json:"teams"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// LoginUserRequestProto defines model for LoginUserRequestProto.
type LoginUserRequestProto struct {
	Data struct {
		// Email User email
		Email string `json:"email"`

		// Password User password
		Password string `json:"password"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// LoginUserResponseProto defines model for LoginUserResponseProto.
type LoginUserResponseProto struct {
	Data struct {
		Pat string `json:"pat"`

		// Token Token for authentication to be used in the Authorization header
		Token string `json:"token"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// NetworkIpRange defines model for NetworkIpRange.
type NetworkIpRange struct {
	// ExternalFrom Optional external start mapped 1:1 to [from, to]
	ExternalFrom *string `json:"external_from"`

	// ExternalTo Optional external range end mapped 1:1 to [from, to]
	ExternalTo *string `json:"external_to"`

	// From Minimum IP address (inclusive)
	From string `json:"from"`

	// To Maximum IP address (inclusive)
	To string `json:"to"`
}

// NetworkIpRanges defines model for NetworkIpRanges.
type NetworkIpRanges struct {
	Network string `json:"network"`

	// NetworkIpRanges All IPs available for allocation
	NetworkIpRanges []NetworkIpRange `json:"network_ip_ranges"`
}

// NetworkSelector defines model for NetworkSelector.
type NetworkSelector struct {
	union json.RawMessage
}

// NetworkSelector0 Retrieve the Networks in specific datacenters
type NetworkSelector0 struct {
	// ByDataCenter Retrieve the Networks in specific datacenters
	ByDataCenter []string `json:"ByDataCenter"`
}

// NodeSelector defines model for NodeSelector.
type NodeSelector struct {
	union json.RawMessage
}

// NodeSelector0 defines model for .
type NodeSelector0 struct {
	ByInstanceTypeAndLocation struct {
		// Datacenters Locations where we can allocate requested instance
		Datacenters *[]string `json:"datacenters"`

		// InstanceType Instance type to rent
		InstanceType string `json:"instance_type"`
	} `json:"ByInstanceTypeAndLocation"`
}

// NodeSelector1 defines model for .
type NodeSelector1 struct {
	ByNodeId struct {
		// InstanceType Instance type to rent
		InstanceType string `json:"instance_type"`

		// NodeId Node ID to rent
		NodeId string `json:"node_id"`
	} `json:"ByNodeId"`
}

// NodeStatus defines model for NodeStatus.
type NodeStatus string

// PasswordResetRequestProto defines model for PasswordResetRequestProto.
type PasswordResetRequestProto struct {
	Data struct {
		// NewPassword New password
		NewPassword string `json:"new_password"`

		// Token Password reset token received in the email
		Token string `json:"token"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// PasswordResetVerifyRequestProto defines model for PasswordResetVerifyRequestProto.
type PasswordResetVerifyRequestProto struct {
	Data struct {
		// Email Email to send the password reset token
		Email string `json:"email"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// PromoCodeRequestProto defines model for PromoCodeRequestProto.
type PromoCodeRequestProto struct {
	Data struct {
		PromoCode string  `json:"promo_code"`
		TeamId    *string `json:"team_id"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ProviderNodeInfo defines model for ProviderNodeInfo.
type ProviderNodeInfo struct {
	Cpu CpuInfo `json:"cpu"`

	// CpuCoresAvailable Number of CPU cores available on the node, i.e. not allocated by the executor
	CpuCoresAvailable int32 `json:"cpu_cores_available"`

	// CpuCoresAvailableMask Available CPU cores as a hex number making a bitmask
	CpuCoresAvailableMask string `json:"cpu_cores_available_mask"`

	// Disks Disks available on the node
	Disks []DiskInfo `json:"disks"`

	// Dram Total node DRAM
	Dram int64 `json:"dram"`

	// DramAvailable DRAM available for renting
	DramAvailable int64 `json:"dram_available"`

	// Gpus Number of gpus on the node
	Gpus []GpuInfo `json:"gpus"`

	// GpusAvailable Number of GPUs available for renting
	GpusAvailable int32 `json:"gpus_available"`

	// GpusAvailableMask Available GPUs as a hex number making a bitmask
	GpusAvailableMask string `json:"gpus_available_mask"`

	// Id ID of the node to be used in rent API request
	Id       string        `json:"id"`
	Instance *InstanceInfo `json:"instance,omitempty"`
}

// Recipe defines model for Recipe.
type Recipe struct {
	// Description Description of the recipe
	Description string        `json:"description"`
	Details     RecipeDetails `json:"details"`

	// InstructionsUrl URL to the instructions for the recipe, if available
	InstructionsUrl *string `json:"instructions_url"`

	// LogoUrl Logo of the recipe, if available, e.g. Ubuntu, PyTorch or Jupyter logo
	LogoUrl *string `json:"logo_url"`

	// Name Name of the recipe
	Name string `json:"name"`

	// Tags Tags for the recipe to help users find it and filter by them
	Tags []string `json:"tags"`
}

// RecipeDetails defines model for RecipeDetails.
type RecipeDetails struct {
	union json.RawMessage
}

// RecipeDetails0 defines model for .
type RecipeDetails0 struct {
	Docker struct {
		// Command Docker command to run the recipe
		Command []string `json:"command"`

		// Env Environment variables to set
		Env [][]interface{} `json:"env"`

		// Image Docker image corresponding to the recipe
		Image string `json:"image"`

		// Ports Ports to expose in the format <host>:<container>:<tcp|udp|sctp>
		Ports []string `json:"ports"`
	} `json:"Docker"`
}

// RecipeDetails1 defines model for .
type RecipeDetails1 struct {
	VirtualMachine struct {
		CloudinitUrl string `json:"cloudinit_url"`

		// ImageUrl VM image to use for the recipe
		ImageUrl string `json:"image_url"`
	} `json:"VirtualMachine"`
}

// RecipeGroup defines model for RecipeGroup.
type RecipeGroup struct {
	// Description Description of the recipe group
	Description string `json:"description"`

	// LogoUrl Logo of the recipe group, if available, e.g. Ubuntu, PyTorch or Jupyter logo
	LogoUrl *string `json:"logo_url"`

	// Metadata JSON string with metadata for the recipe group
	Metadata *string `json:"metadata"`

	// Name Name of the recipe group
	Name string `json:"name"`

	// Recipes Recipes in the group
	Recipes []Recipe `json:"recipes"`

	// Tags Tags for the recipe group to help users find it and filter by them
	Tags []string `json:"tags"`
}

// RegisterUserRequestProto defines model for RegisterUserRequestProto.
type RegisterUserRequestProto struct {
	Data struct {
		// Email New user email
		Email      string  `json:"email"`
		InviteCode *string `json:"invite_code"`

		// Name New user name
		Name string `json:"name"`

		// Password New user password
		Password string `json:"password"`

		// SubscribeNewsletter Whether to subscribe user to newsletter
		SubscribeNewsletter *bool `json:"subscribe_newsletter,omitempty"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// RemoveTeamMemberRequestProto defines model for RemoveTeamMemberRequestProto.
type RemoveTeamMemberRequestProto struct {
	Data struct {
		UserId string `json:"user_id"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// RentInstanceRequestProto defines model for RentInstanceRequestProto.
type RentInstanceRequestProto struct {
	Data struct {
		Config InstanceConfiguration `json:"config"`

		// Network Optional Network name
		Network *string `json:"network"`

		// Recipe Recipe name to use for the instance
		Recipe *string `json:"recipe"`

		// Reservation Parameters for using reservations with instances
		Reservation *ReservationParameters `json:"reservation,omitempty"`
		Selector    NodeSelector           `json:"selector"`

		// TeamId Optional team ID
		TeamId *string `json:"team_id"`

		// WithPublicIp Allocate public IP from the pool
		WithPublicIp bool `json:"with_public_ip"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// RentInstanceResponseProto defines model for RentInstanceResponseProto.
type RentInstanceResponseProto struct {
	Data struct {
		// InstanceIds ID of the instances that were rented
		InstanceIds []string `json:"instance_ids"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// Reservation defines model for Reservation.
type Reservation struct {
	BoundResource   string          `json:"bound_resource"`
	CreatedAt       string          `json:"created_at"`
	Id              string          `json:"id"`
	InstanceType    InstanceType    `json:"instance_type"`
	InstanceVariant InstanceVariant `json:"instance_variant"`
	NodeMode        InstanceMode    `json:"node_mode"`
	ValidTill       string          `json:"valid_till"`
}

// ReservationDates defines model for ReservationDates.
type ReservationDates struct {
	CreatedAt string `json:"created_at"`
	ValidTill string `json:"valid_till"`
}

// ReservationParameters Parameters for using reservations with instances
type ReservationParameters struct {
	union json.RawMessage
}

// ReservationParameters0 Create a new reservation with the selected reservation type ID
type ReservationParameters0 struct {
	// TypeID Create a new reservation with the selected reservation type ID
	TypeID string `json:"TypeID"`
}

// ReservationParameters1 Use an existing reservation by ID
type ReservationParameters1 struct {
	// ID Use an existing reservation by ID
	ID string `json:"ID"`
}

// ReservationSelector defines model for ReservationSelector.
type ReservationSelector struct {
	union json.RawMessage
}

// ReservationSelector0 Select all reservations
type ReservationSelector0 string

// ReservationSelector1 defines model for .
type ReservationSelector1 struct {
	ByTeamId string `json:"ByTeamId"`
}

// ReservationType defines model for ReservationType.
type ReservationType struct {
	Duration    map[string]int32 `json:"duration"`
	Id          string           `json:"id"`
	PriceFactor float64          `json:"price_factor"`
}

// ResponseStatus defines model for ResponseStatus.
type ResponseStatus string

// ServiceCharge defines model for ServiceCharge.
type ServiceCharge struct {
	// Amount Charge amount as a fraction of currency units (cents)
	Amount []interface{} `json:"amount"`

	// RequestId Request ID for idempotency, i.e. to avoid double charges
	RequestId *string `json:"request_id"`

	// UsageMetadata Optional usage metadata, e.g. usage minutes or number of API calls
	UsageMetadata *string `json:"usage_metadata"`
}

// ServiceChargeRequestProto defines model for ServiceChargeRequestProto.
type ServiceChargeRequestProto struct {
	Data struct {
		// Amount Charge amount as a fraction of currency units (cents)
		Amount []interface{} `json:"amount"`

		// Provider Name of the provider of the service
		Provider string `json:"provider"`

		// RequestId Request ID for idempotency, i.e. to avoid double charges
		RequestId *string `json:"request_id"`

		// Service Name of the service to charge
		Service string `json:"service"`

		// UsageMetadata Optional usage metadata, e.g. usage minutes or number of API calls
		UsageMetadata *string `json:"usage_metadata"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// ServiceChargeResponseProto defines model for ServiceChargeResponseProto.
type ServiceChargeResponseProto struct {
	Data struct {
		// RequestId Either a provided request ID or a generated one
		RequestId string `json:"request_id"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// SshKey defines model for SshKey.
type SshKey struct {
	// Id SSH key ID
	Id string `json:"id"`

	// Name SSH key name
	Name string `json:"name"`

	// PublicKey SSH key public part
	PublicKey string `json:"public_key"`
}

// SshKeySelector defines model for SshKeySelector.
type SshKeySelector struct {
	union json.RawMessage
}

// SshKeySelector0 defines model for .
type SshKeySelector0 struct {
	ByName []string `json:"ByName"`
}

// SshKeySelector1 defines model for SshKeySelector.1.
type SshKeySelector1 string

// StripeTransactionInfo defines model for StripeTransactionInfo.
type StripeTransactionInfo struct {
	union json.RawMessage
}

// StripeTransactionInfo0 defines model for .
type StripeTransactionInfo0 struct {
	Payment struct {
		// PaymentIntentId ID of CloudRift payment intent
		PaymentIntentId string `json:"payment_intent_id"`

		// StripePaymentIntentId ID of the Stripe payment
		StripePaymentIntentId *string `json:"stripe_payment_intent_id"`
	} `json:"Payment"`
}

// StripeTransactionInfo1 defines model for .
type StripeTransactionInfo1 struct {
	DisputeOpen struct {
		// StripeDisputeAmount Amount disputed
		StripeDisputeAmount int64 `json:"stripe_dispute_amount"`

		// StripeDisputeFee Additional amount that payment processor charges for Dispute
		StripeDisputeFee int64 `json:"stripe_dispute_fee"`

		// StripeDisputeId Dispute ID
		StripeDisputeId string `json:"stripe_dispute_id"`

		// StripePaymentIntentId ID of the original Stripe payment that is being disputed
		StripePaymentIntentId *string `json:"stripe_payment_intent_id"`
	} `json:"DisputeOpen"`
}

// StripeTransactionInfo2 defines model for .
type StripeTransactionInfo2 struct {
	DisputeClose struct {
		// DisputeFee Dispute fee charged by the payment processor, not refunded
		DisputeFee int64 `json:"dispute_fee"`

		// Refunded Amount refunded
		Refunded int64 `json:"refunded"`

		// StripeDisputeId Dispute ID
		StripeDisputeId string `json:"stripe_dispute_id"`

		// StripeDisputeStatus Status of the dispute like won, lost, etc.
		StripeDisputeStatus string `json:"stripe_dispute_status"`

		// StripePaymentIntentId ID of the original Stripe payment that is being disputed
		StripePaymentIntentId *string `json:"stripe_payment_intent_id"`
	} `json:"DisputeClose"`
}

// Team defines model for Team.
type Team struct {
	AccountId   string  `json:"account_id"`
	CreatedAt   string  `json:"created_at"`
	Description *string `json:"description"`
	Id          string  `json:"id"`
	Name        string  `json:"name"`
	UpdatedAt   string  `json:"updated_at"`
	UserRole    string  `json:"user_role"`
}

// TeamMember defines model for TeamMember.
type TeamMember struct {
	Email    string `json:"email"`
	JoinedAt string `json:"joined_at"`
	Name     string `json:"name"`
	Role     string `json:"role"`
	UserId   string `json:"user_id"`
}

// TeamMemberResponseProto defines model for TeamMemberResponseProto.
type TeamMemberResponseProto struct {
	Data struct {
		Email    string `json:"email"`
		JoinedAt string `json:"joined_at"`
		Name     string `json:"name"`
		Role     string `json:"role"`
		UserId   string `json:"user_id"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// TeamResponseProto defines model for TeamResponseProto.
type TeamResponseProto struct {
	Data struct {
		Members []TeamMember `json:"members"`
		Team    Team         `json:"team"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// TeamRole defines model for TeamRole.
type TeamRole string

// TerminateInstancesRequestProto defines model for TerminateInstancesRequestProto.
type TerminateInstancesRequestProto struct {
	Data struct {
		Selector InstancesSelector `json:"selector"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// Transaction defines model for Transaction.
type Transaction struct {
	// Amount Amount of money in cents, positive for debit and negative for credit
	Amount int64 `json:"amount"`

	// CreatedAt Date and time of the transaction
	CreatedAt string          `json:"created_at"`
	Info      TransactionInfo `json:"info"`
}

// TransactionArrayProto defines model for TransactionArrayProto.
type TransactionArrayProto struct {
	Data struct {
		Transactions []Transaction `json:"transactions"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// TransactionInfo defines model for TransactionInfo.
type TransactionInfo struct {
	union json.RawMessage
}

// TransactionInfo0 User has deposited or withdrawn money to or from their account using Stripe
type TransactionInfo0 struct {
	Stripe StripeTransactionInfo `json:"Stripe"`
}

// TransactionInfo1 Money has been spent on using a service for a certain amount of time
type TransactionInfo1 struct {
	// Usage Money has been spent on using a service for a certain amount of time
	Usage struct {
		// Carryover Carryover from previous transaction included in the current transaction
		Carryover       []interface{}     `json:"carryover"`
		ReservationData *ReservationDates `json:"reservation_data,omitempty"`

		// ResourceId ID of the resource providing the service
		ResourceId string `json:"resource_id"`

		// Rounding Additional charge due to rounding included in the transaction
		Rounding []interface{} `json:"rounding"`

		// UsageMetadata JSON object with the usage data
		UsageMetadata *string `json:"usage_metadata"`
	} `json:"Usage"`
}

// TransactionInfo2 Payout to the provider for service usage
type TransactionInfo2 struct {
	// Payout Payout to the provider for service usage
	Payout struct {
		// Carryover Carryover from previous transaction included in the current transaction
		Carryover []interface{} `json:"carryover"`

		// ResourceId ID of the resource providing the service
		ResourceId string `json:"resource_id"`

		// Rounding Additional charge due to rounding included in the transaction
		Rounding []interface{} `json:"rounding"`

		// UsageCost usage cost for which we're performing the payout
		UsageCost *int64 `json:"usage_cost"`

		// UsageMetadata JSON object with the usage data
		UsageMetadata *string `json:"usage_metadata"`
	} `json:"Payout"`
}

// TransactionInfo3 Charge to the user account by external service
type TransactionInfo3 struct {
	// ServiceUsage Charge to the user account by external service
	ServiceUsage struct {
		// Carryover Carryover from previous transaction included in the current transaction
		Carryover []interface{} `json:"carryover"`

		// Rounding Additional charge due to rounding included in the transaction
		Rounding []interface{} `json:"rounding"`

		// Service Name of the service
		Service string `json:"service"`

		// UsageMetadata JSON object with the usage data
		UsageMetadata *string `json:"usage_metadata"`
	} `json:"ServiceUsage"`
}

// TransactionInfo4 Payout to the provider for usage of external service
type TransactionInfo4 struct {
	// ServicePayout Payout to the provider for usage of external service
	ServicePayout struct {
		// Carryover Carryover from previous transaction included in the current transaction
		Carryover []interface{} `json:"carryover"`

		// Rounding Additional charge due to rounding included in the transaction
		Rounding []interface{} `json:"rounding"`

		// Service Name of the service
		Service string `json:"service"`

		// UsageCost usage cost for which we're performing the payout
		UsageCost *int64 `json:"usage_cost"`

		// UsageMetadata JSON object with the usage data
		UsageMetadata *string `json:"usage_metadata"`
	} `json:"ServicePayout"`
}

// TransactionInfo5 Amount increase due to promo code
type TransactionInfo5 struct {
	// PromoCode Amount increase due to promo code
	PromoCode struct {
		// PromoCode The promo code that was used
		PromoCode string `json:"promo_code"`
	} `json:"PromoCode"`
}

// TransactionInfo6 External transaction, e.g. from or to a bank account
type TransactionInfo6 struct {
	// External External transaction, e.g. from or to a bank account
	External struct {
		// Description Description of the payout
		Description string `json:"description"`
	} `json:"External"`
}

// UpdateApiKeysRequestProto defines model for UpdateApiKeysRequestProto.
type UpdateApiKeysRequestProto struct {
	Data struct {
		// Active Enable/disable API key
		Active *bool `json:"active"`

		// Name Change API key name
		Name     *string        `json:"name"`
		Selector ApiKeySelector `json:"selector"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// UpdateApiKeysResponseProto defines model for UpdateApiKeysResponseProto.
type UpdateApiKeysResponseProto struct {
	Data struct {
		// Keys Information about the updated API keys with their operation status
		Keys   []KeyResult    `json:"keys"`
		Status ResponseStatus `json:"status"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// UpdateTeamMembershipRequestProto defines model for UpdateTeamMembershipRequestProto.
type UpdateTeamMembershipRequestProto struct {
	Data struct {
		Role   TeamRole `json:"role"`
		UserId string   `json:"user_id"`
	} `json:"data"`

	// Version The version of the protocol like 2024-09-22, etc. Specify '~upcoming' to indicate future (unreleased) version or always use latest relesed version.
	Version string `json:"version"`
}

// CreateExternalTransactionJSONRequestBody defines body for CreateExternalTransaction for application/json ContentType.
type CreateExternalTransactionJSONRequestBody = ExternalTransactionRequestProto

// CreatePromoTransactionJSONRequestBody defines body for CreatePromoTransaction for application/json ContentType.
type CreatePromoTransactionJSONRequestBody = PromoCodeRequestProto

// AddApiKeyJSONRequestBody defines body for AddApiKey for application/json ContentType.
type AddApiKeyJSONRequestBody = AddApiKeyRequestProto

// SelectAndDeleteApiKeysJSONRequestBody defines body for SelectAndDeleteApiKeys for application/json ContentType.
type SelectAndDeleteApiKeysJSONRequestBody = DeleteApiKeysRequestProto

// ListApiKeysJSONRequestBody defines body for ListApiKeys for application/json ContentType.
type ListApiKeysJSONRequestBody = ListApiKeysRequestProto

// UpdateApiKeysJSONRequestBody defines body for UpdateApiKeys for application/json ContentType.
type UpdateApiKeysJSONRequestBody = UpdateApiKeysRequestProto

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginUserRequestProto

// RequestPasswordResetJSONRequestBody defines body for RequestPasswordReset for application/json ContentType.
type RequestPasswordResetJSONRequestBody = PasswordResetVerifyRequestProto

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody = PasswordResetRequestProto

// ListInstanceTypesJSONRequestBody defines body for ListInstanceTypes for application/json ContentType.
type ListInstanceTypesJSONRequestBody = ListInstanceTypesRequestProto

// ListInstancesJSONRequestBody defines body for ListInstances for application/json ContentType.
type ListInstancesJSONRequestBody = ListInstancesRequestProto

// RentInstanceJSONRequestBody defines body for RentInstance for application/json ContentType.
type RentInstanceJSONRequestBody = RentInstanceRequestProto

// TerminateInstancesJSONRequestBody defines body for TerminateInstances for application/json ContentType.
type TerminateInstancesJSONRequestBody = TerminateInstancesRequestProto

// AddNetworkJSONRequestBody defines body for AddNetwork for application/json ContentType.
type AddNetworkJSONRequestBody = AddNetworkRequestProto

// ListNetworksJSONRequestBody defines body for ListNetworks for application/json ContentType.
type ListNetworksJSONRequestBody = ListNetworksRequestProto

// ListIpRangesJSONRequestBody defines body for ListIpRanges for application/json ContentType.
type ListIpRangesJSONRequestBody = ListIpRangesRequestProto

// ListProvidersJSONRequestBody defines body for ListProviders for application/json ContentType.
type ListProvidersJSONRequestBody = ListProvidersRequestProto

// ListProviderNodesJSONRequestBody defines body for ListProviderNodes for application/json ContentType.
type ListProviderNodesJSONRequestBody = ListProviderNodesRequestProto

// ListReservationsJSONRequestBody defines body for ListReservations for application/json ContentType.
type ListReservationsJSONRequestBody = ListReservationsRequestProto

// BulkChargeForServiceJSONRequestBody defines body for BulkChargeForService for application/json ContentType.
type BulkChargeForServiceJSONRequestBody = BulkServiceChargeRequestProto

// ChargeForServiceJSONRequestBody defines body for ChargeForService for application/json ContentType.
type ChargeForServiceJSONRequestBody = ServiceChargeRequestProto

// AddSshKeyJSONRequestBody defines body for AddSshKey for application/json ContentType.
type AddSshKeyJSONRequestBody = AddSshKeyRequestProto

// SelectAndDeleteSshKeyJSONRequestBody defines body for SelectAndDeleteSshKey for application/json ContentType.
type SelectAndDeleteSshKeyJSONRequestBody = DeleteSshKeyRequestProto

// CreateTeamJSONRequestBody defines body for CreateTeam for application/json ContentType.
type CreateTeamJSONRequestBody = CreateTeamRequestProto

// AddTeamMemberJSONRequestBody defines body for AddTeamMember for application/json ContentType.
type AddTeamMemberJSONRequestBody = AddTeamMemberRequestProto

// RemoveTeamMemberJSONRequestBody defines body for RemoveTeamMember for application/json ContentType.
type RemoveTeamMemberJSONRequestBody = RemoveTeamMemberRequestProto

// UpdateTeamMembershipJSONRequestBody defines body for UpdateTeamMembership for application/json ContentType.
type UpdateTeamMembershipJSONRequestBody = UpdateTeamMembershipRequestProto

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = RegisterUserRequestProto

// AsAccountSelector0 returns the union data inside the AccountSelector as a AccountSelector0
func (t AccountSelector) AsAccountSelector0() (AccountSelector0, error) {
	var body AccountSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccountSelector0 overwrites any union data inside the AccountSelector as the provided AccountSelector0
func (t *AccountSelector) FromAccountSelector0(v AccountSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccountSelector0 performs a merge with any union data inside the AccountSelector, using the provided AccountSelector0
func (t *AccountSelector) MergeAccountSelector0(v AccountSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAccountSelector1 returns the union data inside the AccountSelector as a AccountSelector1
func (t AccountSelector) AsAccountSelector1() (AccountSelector1, error) {
	var body AccountSelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccountSelector1 overwrites any union data inside the AccountSelector as the provided AccountSelector1
func (t *AccountSelector) FromAccountSelector1(v AccountSelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccountSelector1 performs a merge with any union data inside the AccountSelector, using the provided AccountSelector1
func (t *AccountSelector) MergeAccountSelector1(v AccountSelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AccountSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AccountSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsApiKeySelector0 returns the union data inside the ApiKeySelector as a ApiKeySelector0
func (t ApiKeySelector) AsApiKeySelector0() (ApiKeySelector0, error) {
	var body ApiKeySelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiKeySelector0 overwrites any union data inside the ApiKeySelector as the provided ApiKeySelector0
func (t *ApiKeySelector) FromApiKeySelector0(v ApiKeySelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiKeySelector0 performs a merge with any union data inside the ApiKeySelector, using the provided ApiKeySelector0
func (t *ApiKeySelector) MergeApiKeySelector0(v ApiKeySelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsApiKeySelector1 returns the union data inside the ApiKeySelector as a ApiKeySelector1
func (t ApiKeySelector) AsApiKeySelector1() (ApiKeySelector1, error) {
	var body ApiKeySelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiKeySelector1 overwrites any union data inside the ApiKeySelector as the provided ApiKeySelector1
func (t *ApiKeySelector) FromApiKeySelector1(v ApiKeySelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiKeySelector1 performs a merge with any union data inside the ApiKeySelector, using the provided ApiKeySelector1
func (t *ApiKeySelector) MergeApiKeySelector1(v ApiKeySelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsApiKeySelector2 returns the union data inside the ApiKeySelector as a ApiKeySelector2
func (t ApiKeySelector) AsApiKeySelector2() (ApiKeySelector2, error) {
	var body ApiKeySelector2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiKeySelector2 overwrites any union data inside the ApiKeySelector as the provided ApiKeySelector2
func (t *ApiKeySelector) FromApiKeySelector2(v ApiKeySelector2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiKeySelector2 performs a merge with any union data inside the ApiKeySelector, using the provided ApiKeySelector2
func (t *ApiKeySelector) MergeApiKeySelector2(v ApiKeySelector2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiKeySelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiKeySelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsComputeProviderSelector0 returns the union data inside the ComputeProviderSelector as a ComputeProviderSelector0
func (t ComputeProviderSelector) AsComputeProviderSelector0() (ComputeProviderSelector0, error) {
	var body ComputeProviderSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromComputeProviderSelector0 overwrites any union data inside the ComputeProviderSelector as the provided ComputeProviderSelector0
func (t *ComputeProviderSelector) FromComputeProviderSelector0(v ComputeProviderSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeComputeProviderSelector0 performs a merge with any union data inside the ComputeProviderSelector, using the provided ComputeProviderSelector0
func (t *ComputeProviderSelector) MergeComputeProviderSelector0(v ComputeProviderSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsComputeProviderSelector1 returns the union data inside the ComputeProviderSelector as a ComputeProviderSelector1
func (t ComputeProviderSelector) AsComputeProviderSelector1() (ComputeProviderSelector1, error) {
	var body ComputeProviderSelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromComputeProviderSelector1 overwrites any union data inside the ComputeProviderSelector as the provided ComputeProviderSelector1
func (t *ComputeProviderSelector) FromComputeProviderSelector1(v ComputeProviderSelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeComputeProviderSelector1 performs a merge with any union data inside the ComputeProviderSelector, using the provided ComputeProviderSelector1
func (t *ComputeProviderSelector) MergeComputeProviderSelector1(v ComputeProviderSelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ComputeProviderSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ComputeProviderSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDockerRegistryAuth0 returns the union data inside the DockerRegistryAuth as a DockerRegistryAuth0
func (t DockerRegistryAuth) AsDockerRegistryAuth0() (DockerRegistryAuth0, error) {
	var body DockerRegistryAuth0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerRegistryAuth0 overwrites any union data inside the DockerRegistryAuth as the provided DockerRegistryAuth0
func (t *DockerRegistryAuth) FromDockerRegistryAuth0(v DockerRegistryAuth0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerRegistryAuth0 performs a merge with any union data inside the DockerRegistryAuth, using the provided DockerRegistryAuth0
func (t *DockerRegistryAuth) MergeDockerRegistryAuth0(v DockerRegistryAuth0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DockerRegistryAuth) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DockerRegistryAuth) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInstanceConfiguration0 returns the union data inside the InstanceConfiguration as a InstanceConfiguration0
func (t InstanceConfiguration) AsInstanceConfiguration0() (InstanceConfiguration0, error) {
	var body InstanceConfiguration0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceConfiguration0 overwrites any union data inside the InstanceConfiguration as the provided InstanceConfiguration0
func (t *InstanceConfiguration) FromInstanceConfiguration0(v InstanceConfiguration0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceConfiguration0 performs a merge with any union data inside the InstanceConfiguration, using the provided InstanceConfiguration0
func (t *InstanceConfiguration) MergeInstanceConfiguration0(v InstanceConfiguration0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceConfiguration1 returns the union data inside the InstanceConfiguration as a InstanceConfiguration1
func (t InstanceConfiguration) AsInstanceConfiguration1() (InstanceConfiguration1, error) {
	var body InstanceConfiguration1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceConfiguration1 overwrites any union data inside the InstanceConfiguration as the provided InstanceConfiguration1
func (t *InstanceConfiguration) FromInstanceConfiguration1(v InstanceConfiguration1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceConfiguration1 performs a merge with any union data inside the InstanceConfiguration, using the provided InstanceConfiguration1
func (t *InstanceConfiguration) MergeInstanceConfiguration1(v InstanceConfiguration1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceConfiguration2 returns the union data inside the InstanceConfiguration as a InstanceConfiguration2
func (t InstanceConfiguration) AsInstanceConfiguration2() (InstanceConfiguration2, error) {
	var body InstanceConfiguration2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceConfiguration2 overwrites any union data inside the InstanceConfiguration as the provided InstanceConfiguration2
func (t *InstanceConfiguration) FromInstanceConfiguration2(v InstanceConfiguration2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceConfiguration2 performs a merge with any union data inside the InstanceConfiguration, using the provided InstanceConfiguration2
func (t *InstanceConfiguration) MergeInstanceConfiguration2(v InstanceConfiguration2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InstanceConfiguration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InstanceConfiguration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInstanceLoginInfo0 returns the union data inside the InstanceLoginInfo as a InstanceLoginInfo0
func (t InstanceLoginInfo) AsInstanceLoginInfo0() (InstanceLoginInfo0, error) {
	var body InstanceLoginInfo0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceLoginInfo0 overwrites any union data inside the InstanceLoginInfo as the provided InstanceLoginInfo0
func (t *InstanceLoginInfo) FromInstanceLoginInfo0(v InstanceLoginInfo0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceLoginInfo0 performs a merge with any union data inside the InstanceLoginInfo, using the provided InstanceLoginInfo0
func (t *InstanceLoginInfo) MergeInstanceLoginInfo0(v InstanceLoginInfo0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceLoginInfo1 returns the union data inside the InstanceLoginInfo as a InstanceLoginInfo1
func (t InstanceLoginInfo) AsInstanceLoginInfo1() (InstanceLoginInfo1, error) {
	var body InstanceLoginInfo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceLoginInfo1 overwrites any union data inside the InstanceLoginInfo as the provided InstanceLoginInfo1
func (t *InstanceLoginInfo) FromInstanceLoginInfo1(v InstanceLoginInfo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceLoginInfo1 performs a merge with any union data inside the InstanceLoginInfo, using the provided InstanceLoginInfo1
func (t *InstanceLoginInfo) MergeInstanceLoginInfo1(v InstanceLoginInfo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InstanceLoginInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InstanceLoginInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInstanceSshKeySelector0 returns the union data inside the InstanceSshKeySelector as a InstanceSshKeySelector0
func (t InstanceSshKeySelector) AsInstanceSshKeySelector0() (InstanceSshKeySelector0, error) {
	var body InstanceSshKeySelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceSshKeySelector0 overwrites any union data inside the InstanceSshKeySelector as the provided InstanceSshKeySelector0
func (t *InstanceSshKeySelector) FromInstanceSshKeySelector0(v InstanceSshKeySelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceSshKeySelector0 performs a merge with any union data inside the InstanceSshKeySelector, using the provided InstanceSshKeySelector0
func (t *InstanceSshKeySelector) MergeInstanceSshKeySelector0(v InstanceSshKeySelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceSshKeySelector1 returns the union data inside the InstanceSshKeySelector as a InstanceSshKeySelector1
func (t InstanceSshKeySelector) AsInstanceSshKeySelector1() (InstanceSshKeySelector1, error) {
	var body InstanceSshKeySelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceSshKeySelector1 overwrites any union data inside the InstanceSshKeySelector as the provided InstanceSshKeySelector1
func (t *InstanceSshKeySelector) FromInstanceSshKeySelector1(v InstanceSshKeySelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceSshKeySelector1 performs a merge with any union data inside the InstanceSshKeySelector, using the provided InstanceSshKeySelector1
func (t *InstanceSshKeySelector) MergeInstanceSshKeySelector1(v InstanceSshKeySelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceSshKeySelector2 returns the union data inside the InstanceSshKeySelector as a InstanceSshKeySelector2
func (t InstanceSshKeySelector) AsInstanceSshKeySelector2() (InstanceSshKeySelector2, error) {
	var body InstanceSshKeySelector2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceSshKeySelector2 overwrites any union data inside the InstanceSshKeySelector as the provided InstanceSshKeySelector2
func (t *InstanceSshKeySelector) FromInstanceSshKeySelector2(v InstanceSshKeySelector2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceSshKeySelector2 performs a merge with any union data inside the InstanceSshKeySelector, using the provided InstanceSshKeySelector2
func (t *InstanceSshKeySelector) MergeInstanceSshKeySelector2(v InstanceSshKeySelector2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InstanceSshKeySelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InstanceSshKeySelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInstanceTypeSelector0 returns the union data inside the InstanceTypeSelector as a InstanceTypeSelector0
func (t InstanceTypeSelector) AsInstanceTypeSelector0() (InstanceTypeSelector0, error) {
	var body InstanceTypeSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceTypeSelector0 overwrites any union data inside the InstanceTypeSelector as the provided InstanceTypeSelector0
func (t *InstanceTypeSelector) FromInstanceTypeSelector0(v InstanceTypeSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceTypeSelector0 performs a merge with any union data inside the InstanceTypeSelector, using the provided InstanceTypeSelector0
func (t *InstanceTypeSelector) MergeInstanceTypeSelector0(v InstanceTypeSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceTypeSelector1 returns the union data inside the InstanceTypeSelector as a InstanceTypeSelector1
func (t InstanceTypeSelector) AsInstanceTypeSelector1() (InstanceTypeSelector1, error) {
	var body InstanceTypeSelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceTypeSelector1 overwrites any union data inside the InstanceTypeSelector as the provided InstanceTypeSelector1
func (t *InstanceTypeSelector) FromInstanceTypeSelector1(v InstanceTypeSelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceTypeSelector1 performs a merge with any union data inside the InstanceTypeSelector, using the provided InstanceTypeSelector1
func (t *InstanceTypeSelector) MergeInstanceTypeSelector1(v InstanceTypeSelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceTypeSelector2 returns the union data inside the InstanceTypeSelector as a InstanceTypeSelector2
func (t InstanceTypeSelector) AsInstanceTypeSelector2() (InstanceTypeSelector2, error) {
	var body InstanceTypeSelector2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceTypeSelector2 overwrites any union data inside the InstanceTypeSelector as the provided InstanceTypeSelector2
func (t *InstanceTypeSelector) FromInstanceTypeSelector2(v InstanceTypeSelector2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceTypeSelector2 performs a merge with any union data inside the InstanceTypeSelector, using the provided InstanceTypeSelector2
func (t *InstanceTypeSelector) MergeInstanceTypeSelector2(v InstanceTypeSelector2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceTypeSelector3 returns the union data inside the InstanceTypeSelector as a InstanceTypeSelector3
func (t InstanceTypeSelector) AsInstanceTypeSelector3() (InstanceTypeSelector3, error) {
	var body InstanceTypeSelector3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceTypeSelector3 overwrites any union data inside the InstanceTypeSelector as the provided InstanceTypeSelector3
func (t *InstanceTypeSelector) FromInstanceTypeSelector3(v InstanceTypeSelector3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceTypeSelector3 performs a merge with any union data inside the InstanceTypeSelector, using the provided InstanceTypeSelector3
func (t *InstanceTypeSelector) MergeInstanceTypeSelector3(v InstanceTypeSelector3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InstanceTypeSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InstanceTypeSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInstancesSelector0 returns the union data inside the InstancesSelector as a InstancesSelector0
func (t InstancesSelector) AsInstancesSelector0() (InstancesSelector0, error) {
	var body InstancesSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstancesSelector0 overwrites any union data inside the InstancesSelector as the provided InstancesSelector0
func (t *InstancesSelector) FromInstancesSelector0(v InstancesSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstancesSelector0 performs a merge with any union data inside the InstancesSelector, using the provided InstancesSelector0
func (t *InstancesSelector) MergeInstancesSelector0(v InstancesSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstancesSelector1 returns the union data inside the InstancesSelector as a InstancesSelector1
func (t InstancesSelector) AsInstancesSelector1() (InstancesSelector1, error) {
	var body InstancesSelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstancesSelector1 overwrites any union data inside the InstancesSelector as the provided InstancesSelector1
func (t *InstancesSelector) FromInstancesSelector1(v InstancesSelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstancesSelector1 performs a merge with any union data inside the InstancesSelector, using the provided InstancesSelector1
func (t *InstancesSelector) MergeInstancesSelector1(v InstancesSelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstancesSelector2 returns the union data inside the InstancesSelector as a InstancesSelector2
func (t InstancesSelector) AsInstancesSelector2() (InstancesSelector2, error) {
	var body InstancesSelector2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstancesSelector2 overwrites any union data inside the InstancesSelector as the provided InstancesSelector2
func (t *InstancesSelector) FromInstancesSelector2(v InstancesSelector2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstancesSelector2 performs a merge with any union data inside the InstancesSelector, using the provided InstancesSelector2
func (t *InstancesSelector) MergeInstancesSelector2(v InstancesSelector2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InstancesSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InstancesSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNetworkSelector0 returns the union data inside the NetworkSelector as a NetworkSelector0
func (t NetworkSelector) AsNetworkSelector0() (NetworkSelector0, error) {
	var body NetworkSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkSelector0 overwrites any union data inside the NetworkSelector as the provided NetworkSelector0
func (t *NetworkSelector) FromNetworkSelector0(v NetworkSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkSelector0 performs a merge with any union data inside the NetworkSelector, using the provided NetworkSelector0
func (t *NetworkSelector) MergeNetworkSelector0(v NetworkSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NetworkSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NetworkSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNodeSelector0 returns the union data inside the NodeSelector as a NodeSelector0
func (t NodeSelector) AsNodeSelector0() (NodeSelector0, error) {
	var body NodeSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelector0 overwrites any union data inside the NodeSelector as the provided NodeSelector0
func (t *NodeSelector) FromNodeSelector0(v NodeSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelector0 performs a merge with any union data inside the NodeSelector, using the provided NodeSelector0
func (t *NodeSelector) MergeNodeSelector0(v NodeSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelector1 returns the union data inside the NodeSelector as a NodeSelector1
func (t NodeSelector) AsNodeSelector1() (NodeSelector1, error) {
	var body NodeSelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelector1 overwrites any union data inside the NodeSelector as the provided NodeSelector1
func (t *NodeSelector) FromNodeSelector1(v NodeSelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelector1 performs a merge with any union data inside the NodeSelector, using the provided NodeSelector1
func (t *NodeSelector) MergeNodeSelector1(v NodeSelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NodeSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NodeSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRecipeDetails0 returns the union data inside the RecipeDetails as a RecipeDetails0
func (t RecipeDetails) AsRecipeDetails0() (RecipeDetails0, error) {
	var body RecipeDetails0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecipeDetails0 overwrites any union data inside the RecipeDetails as the provided RecipeDetails0
func (t *RecipeDetails) FromRecipeDetails0(v RecipeDetails0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecipeDetails0 performs a merge with any union data inside the RecipeDetails, using the provided RecipeDetails0
func (t *RecipeDetails) MergeRecipeDetails0(v RecipeDetails0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRecipeDetails1 returns the union data inside the RecipeDetails as a RecipeDetails1
func (t RecipeDetails) AsRecipeDetails1() (RecipeDetails1, error) {
	var body RecipeDetails1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRecipeDetails1 overwrites any union data inside the RecipeDetails as the provided RecipeDetails1
func (t *RecipeDetails) FromRecipeDetails1(v RecipeDetails1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRecipeDetails1 performs a merge with any union data inside the RecipeDetails, using the provided RecipeDetails1
func (t *RecipeDetails) MergeRecipeDetails1(v RecipeDetails1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RecipeDetails) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecipeDetails) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReservationParameters0 returns the union data inside the ReservationParameters as a ReservationParameters0
func (t ReservationParameters) AsReservationParameters0() (ReservationParameters0, error) {
	var body ReservationParameters0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReservationParameters0 overwrites any union data inside the ReservationParameters as the provided ReservationParameters0
func (t *ReservationParameters) FromReservationParameters0(v ReservationParameters0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReservationParameters0 performs a merge with any union data inside the ReservationParameters, using the provided ReservationParameters0
func (t *ReservationParameters) MergeReservationParameters0(v ReservationParameters0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReservationParameters1 returns the union data inside the ReservationParameters as a ReservationParameters1
func (t ReservationParameters) AsReservationParameters1() (ReservationParameters1, error) {
	var body ReservationParameters1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReservationParameters1 overwrites any union data inside the ReservationParameters as the provided ReservationParameters1
func (t *ReservationParameters) FromReservationParameters1(v ReservationParameters1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReservationParameters1 performs a merge with any union data inside the ReservationParameters, using the provided ReservationParameters1
func (t *ReservationParameters) MergeReservationParameters1(v ReservationParameters1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReservationParameters) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReservationParameters) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReservationSelector0 returns the union data inside the ReservationSelector as a ReservationSelector0
func (t ReservationSelector) AsReservationSelector0() (ReservationSelector0, error) {
	var body ReservationSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReservationSelector0 overwrites any union data inside the ReservationSelector as the provided ReservationSelector0
func (t *ReservationSelector) FromReservationSelector0(v ReservationSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReservationSelector0 performs a merge with any union data inside the ReservationSelector, using the provided ReservationSelector0
func (t *ReservationSelector) MergeReservationSelector0(v ReservationSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReservationSelector1 returns the union data inside the ReservationSelector as a ReservationSelector1
func (t ReservationSelector) AsReservationSelector1() (ReservationSelector1, error) {
	var body ReservationSelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReservationSelector1 overwrites any union data inside the ReservationSelector as the provided ReservationSelector1
func (t *ReservationSelector) FromReservationSelector1(v ReservationSelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReservationSelector1 performs a merge with any union data inside the ReservationSelector, using the provided ReservationSelector1
func (t *ReservationSelector) MergeReservationSelector1(v ReservationSelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReservationSelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReservationSelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSshKeySelector0 returns the union data inside the SshKeySelector as a SshKeySelector0
func (t SshKeySelector) AsSshKeySelector0() (SshKeySelector0, error) {
	var body SshKeySelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSshKeySelector0 overwrites any union data inside the SshKeySelector as the provided SshKeySelector0
func (t *SshKeySelector) FromSshKeySelector0(v SshKeySelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSshKeySelector0 performs a merge with any union data inside the SshKeySelector, using the provided SshKeySelector0
func (t *SshKeySelector) MergeSshKeySelector0(v SshKeySelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSshKeySelector1 returns the union data inside the SshKeySelector as a SshKeySelector1
func (t SshKeySelector) AsSshKeySelector1() (SshKeySelector1, error) {
	var body SshKeySelector1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSshKeySelector1 overwrites any union data inside the SshKeySelector as the provided SshKeySelector1
func (t *SshKeySelector) FromSshKeySelector1(v SshKeySelector1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSshKeySelector1 performs a merge with any union data inside the SshKeySelector, using the provided SshKeySelector1
func (t *SshKeySelector) MergeSshKeySelector1(v SshKeySelector1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SshKeySelector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SshKeySelector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStripeTransactionInfo0 returns the union data inside the StripeTransactionInfo as a StripeTransactionInfo0
func (t StripeTransactionInfo) AsStripeTransactionInfo0() (StripeTransactionInfo0, error) {
	var body StripeTransactionInfo0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeTransactionInfo0 overwrites any union data inside the StripeTransactionInfo as the provided StripeTransactionInfo0
func (t *StripeTransactionInfo) FromStripeTransactionInfo0(v StripeTransactionInfo0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeTransactionInfo0 performs a merge with any union data inside the StripeTransactionInfo, using the provided StripeTransactionInfo0
func (t *StripeTransactionInfo) MergeStripeTransactionInfo0(v StripeTransactionInfo0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStripeTransactionInfo1 returns the union data inside the StripeTransactionInfo as a StripeTransactionInfo1
func (t StripeTransactionInfo) AsStripeTransactionInfo1() (StripeTransactionInfo1, error) {
	var body StripeTransactionInfo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeTransactionInfo1 overwrites any union data inside the StripeTransactionInfo as the provided StripeTransactionInfo1
func (t *StripeTransactionInfo) FromStripeTransactionInfo1(v StripeTransactionInfo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeTransactionInfo1 performs a merge with any union data inside the StripeTransactionInfo, using the provided StripeTransactionInfo1
func (t *StripeTransactionInfo) MergeStripeTransactionInfo1(v StripeTransactionInfo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStripeTransactionInfo2 returns the union data inside the StripeTransactionInfo as a StripeTransactionInfo2
func (t StripeTransactionInfo) AsStripeTransactionInfo2() (StripeTransactionInfo2, error) {
	var body StripeTransactionInfo2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeTransactionInfo2 overwrites any union data inside the StripeTransactionInfo as the provided StripeTransactionInfo2
func (t *StripeTransactionInfo) FromStripeTransactionInfo2(v StripeTransactionInfo2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeTransactionInfo2 performs a merge with any union data inside the StripeTransactionInfo, using the provided StripeTransactionInfo2
func (t *StripeTransactionInfo) MergeStripeTransactionInfo2(v StripeTransactionInfo2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StripeTransactionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StripeTransactionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTransactionInfo0 returns the union data inside the TransactionInfo as a TransactionInfo0
func (t TransactionInfo) AsTransactionInfo0() (TransactionInfo0, error) {
	var body TransactionInfo0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionInfo0 overwrites any union data inside the TransactionInfo as the provided TransactionInfo0
func (t *TransactionInfo) FromTransactionInfo0(v TransactionInfo0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionInfo0 performs a merge with any union data inside the TransactionInfo, using the provided TransactionInfo0
func (t *TransactionInfo) MergeTransactionInfo0(v TransactionInfo0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransactionInfo1 returns the union data inside the TransactionInfo as a TransactionInfo1
func (t TransactionInfo) AsTransactionInfo1() (TransactionInfo1, error) {
	var body TransactionInfo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionInfo1 overwrites any union data inside the TransactionInfo as the provided TransactionInfo1
func (t *TransactionInfo) FromTransactionInfo1(v TransactionInfo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionInfo1 performs a merge with any union data inside the TransactionInfo, using the provided TransactionInfo1
func (t *TransactionInfo) MergeTransactionInfo1(v TransactionInfo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransactionInfo2 returns the union data inside the TransactionInfo as a TransactionInfo2
func (t TransactionInfo) AsTransactionInfo2() (TransactionInfo2, error) {
	var body TransactionInfo2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionInfo2 overwrites any union data inside the TransactionInfo as the provided TransactionInfo2
func (t *TransactionInfo) FromTransactionInfo2(v TransactionInfo2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionInfo2 performs a merge with any union data inside the TransactionInfo, using the provided TransactionInfo2
func (t *TransactionInfo) MergeTransactionInfo2(v TransactionInfo2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransactionInfo3 returns the union data inside the TransactionInfo as a TransactionInfo3
func (t TransactionInfo) AsTransactionInfo3() (TransactionInfo3, error) {
	var body TransactionInfo3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionInfo3 overwrites any union data inside the TransactionInfo as the provided TransactionInfo3
func (t *TransactionInfo) FromTransactionInfo3(v TransactionInfo3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionInfo3 performs a merge with any union data inside the TransactionInfo, using the provided TransactionInfo3
func (t *TransactionInfo) MergeTransactionInfo3(v TransactionInfo3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransactionInfo4 returns the union data inside the TransactionInfo as a TransactionInfo4
func (t TransactionInfo) AsTransactionInfo4() (TransactionInfo4, error) {
	var body TransactionInfo4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionInfo4 overwrites any union data inside the TransactionInfo as the provided TransactionInfo4
func (t *TransactionInfo) FromTransactionInfo4(v TransactionInfo4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionInfo4 performs a merge with any union data inside the TransactionInfo, using the provided TransactionInfo4
func (t *TransactionInfo) MergeTransactionInfo4(v TransactionInfo4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransactionInfo5 returns the union data inside the TransactionInfo as a TransactionInfo5
func (t TransactionInfo) AsTransactionInfo5() (TransactionInfo5, error) {
	var body TransactionInfo5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionInfo5 overwrites any union data inside the TransactionInfo as the provided TransactionInfo5
func (t *TransactionInfo) FromTransactionInfo5(v TransactionInfo5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionInfo5 performs a merge with any union data inside the TransactionInfo, using the provided TransactionInfo5
func (t *TransactionInfo) MergeTransactionInfo5(v TransactionInfo5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransactionInfo6 returns the union data inside the TransactionInfo as a TransactionInfo6
func (t TransactionInfo) AsTransactionInfo6() (TransactionInfo6, error) {
	var body TransactionInfo6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransactionInfo6 overwrites any union data inside the TransactionInfo as the provided TransactionInfo6
func (t *TransactionInfo) FromTransactionInfo6(v TransactionInfo6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransactionInfo6 performs a merge with any union data inside the TransactionInfo, using the provided TransactionInfo6
func (t *TransactionInfo) MergeTransactionInfo6(v TransactionInfo6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransactionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransactionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccountInfo request
	GetAccountInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExternalTransactionWithBody request with any body
	CreateExternalTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateExternalTransaction(ctx context.Context, body CreateExternalTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePromoTransactionWithBody request with any body
	CreatePromoTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePromoTransaction(ctx context.Context, body CreatePromoTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactions request
	ListTransactions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddApiKeyWithBody request with any body
	AddApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddApiKey(ctx context.Context, body AddApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SelectAndDeleteApiKeysWithBody request with any body
	SelectAndDeleteApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SelectAndDeleteApiKeys(ctx context.Context, body SelectAndDeleteApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiKeysWithBody request with any body
	ListApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListApiKeys(ctx context.Context, body ListApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateApiKeysWithBody request with any body
	UpdateApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApiKeys(ctx context.Context, body UpdateApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestPasswordResetWithBody request with any body
	RequestPasswordResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestPasswordReset(ctx context.Context, body RequestPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordWithBody request with any body
	ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInstanceTypesWithBody request with any body
	ListInstanceTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListInstanceTypes(ctx context.Context, body ListInstanceTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInstancesWithBody request with any body
	ListInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListInstances(ctx context.Context, body ListInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RentInstanceWithBody request with any body
	RentInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RentInstance(ctx context.Context, body RentInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TerminateInstancesWithBody request with any body
	TerminateInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TerminateInstances(ctx context.Context, body TerminateInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddNetworkWithBody request with any body
	AddNetworkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddNetwork(ctx context.Context, body AddNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNetworksWithBody request with any body
	ListNetworksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListNetworks(ctx context.Context, body ListNetworksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIpRangesWithBody request with any body
	ListIpRangesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListIpRanges(ctx context.Context, body ListIpRangesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProvidersWithBody request with any body
	ListProvidersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListProviders(ctx context.Context, body ListProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProviderNodesWithBody request with any body
	ListProviderNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListProviderNodes(ctx context.Context, body ListProviderNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRecipes request
	ListRecipes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReservationsWithBody request with any body
	ListReservationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListReservations(ctx context.Context, body ListReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReservationTypes request
	ListReservationTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkChargeForServiceWithBody request with any body
	BulkChargeForServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkChargeForService(ctx context.Context, body BulkChargeForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChargeForServiceWithBody request with any body
	ChargeForServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChargeForService(ctx context.Context, body ChargeForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSshKeyWithBody request with any body
	AddSshKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddSshKey(ctx context.Context, body AddSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SelectAndDeleteSshKeyWithBody request with any body
	SelectAndDeleteSshKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SelectAndDeleteSshKey(ctx context.Context, body SelectAndDeleteSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSshKeys request
	ListSshKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSshKey request
	DeleteSshKey(ctx context.Context, sshKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamWithBody request with any body
	CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeams request
	ListTeams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeam request
	GetTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTeamMemberWithBody request with any body
	AddTeamMemberWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTeamMember(ctx context.Context, teamId string, body AddTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTeamMemberWithBody request with any body
	RemoveTeamMemberWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveTeamMember(ctx context.Context, teamId string, body RemoveTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamMembershipWithBody request with any body
	UpdateTeamMembershipWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeamMembership(ctx context.Context, teamId string, body UpdateTeamMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterUserWithBody request with any body
	RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccountInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExternalTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExternalTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExternalTransaction(ctx context.Context, body CreateExternalTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExternalTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePromoTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePromoTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePromoTransaction(ctx context.Context, body CreatePromoTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePromoTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddApiKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddApiKey(ctx context.Context, body AddApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddApiKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectAndDeleteApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectAndDeleteApiKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectAndDeleteApiKeys(ctx context.Context, body SelectAndDeleteApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectAndDeleteApiKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiKeys(ctx context.Context, body ListApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApiKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApiKeys(ctx context.Context, body UpdateApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApiKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestPasswordResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestPasswordResetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestPasswordReset(ctx context.Context, body RequestPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestPasswordResetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstanceTypesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstanceTypesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstanceTypes(ctx context.Context, body ListInstanceTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstanceTypesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstances(ctx context.Context, body ListInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RentInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRentInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RentInstance(ctx context.Context, body RentInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRentInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateInstancesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateInstancesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TerminateInstances(ctx context.Context, body TerminateInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTerminateInstancesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNetworkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNetworkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNetwork(ctx context.Context, body AddNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNetworkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNetworksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNetworksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNetworks(ctx context.Context, body ListNetworksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNetworksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIpRangesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIpRangesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIpRanges(ctx context.Context, body ListIpRangesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIpRangesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProvidersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProvidersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProviders(ctx context.Context, body ListProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProvidersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProviderNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProviderNodesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProviderNodes(ctx context.Context, body ListProviderNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProviderNodesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRecipes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRecipesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReservationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReservationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReservations(ctx context.Context, body ListReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReservationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReservationTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReservationTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkChargeForServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkChargeForServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkChargeForService(ctx context.Context, body BulkChargeForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkChargeForServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChargeForServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChargeForServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChargeForService(ctx context.Context, body ChargeForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChargeForServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSshKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSshKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSshKey(ctx context.Context, body AddSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSshKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectAndDeleteSshKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectAndDeleteSshKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SelectAndDeleteSshKey(ctx context.Context, body SelectAndDeleteSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSelectAndDeleteSshKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSshKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSshKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSshKey(ctx context.Context, sshKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSshKeyRequest(c.Server, sshKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamMemberWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamMemberRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTeamMember(ctx context.Context, teamId string, body AddTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTeamMemberRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTeamMemberWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTeamMemberRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTeamMember(ctx context.Context, teamId string, body RemoveTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTeamMemberRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamMembershipWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamMembershipRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamMembership(ctx context.Context, teamId string, body UpdateTeamMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamMembershipRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountInfoRequest generates requests for GetAccountInfo
func NewGetAccountInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/account/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExternalTransactionRequest calls the generic CreateExternalTransaction builder with application/json body
func NewCreateExternalTransactionRequest(server string, body CreateExternalTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateExternalTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateExternalTransactionRequestWithBody generates requests for CreateExternalTransaction with any type of body
func NewCreateExternalTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/account/transactions/create/external")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePromoTransactionRequest calls the generic CreatePromoTransaction builder with application/json body
func NewCreatePromoTransactionRequest(server string, body CreatePromoTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePromoTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePromoTransactionRequestWithBody generates requests for CreatePromoTransaction with any type of body
func NewCreatePromoTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/account/transactions/create/promo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTransactionsRequest generates requests for ListTransactions
func NewListTransactionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/account/transactions/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddApiKeyRequest calls the generic AddApiKey builder with application/json body
func NewAddApiKeyRequest(server string, body AddApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddApiKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewAddApiKeyRequestWithBody generates requests for AddApiKey with any type of body
func NewAddApiKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/api-keys/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSelectAndDeleteApiKeysRequest calls the generic SelectAndDeleteApiKeys builder with application/json body
func NewSelectAndDeleteApiKeysRequest(server string, body SelectAndDeleteApiKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSelectAndDeleteApiKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewSelectAndDeleteApiKeysRequestWithBody generates requests for SelectAndDeleteApiKeys with any type of body
func NewSelectAndDeleteApiKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/api-keys/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListApiKeysRequest calls the generic ListApiKeys builder with application/json body
func NewListApiKeysRequest(server string, body ListApiKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListApiKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewListApiKeysRequestWithBody generates requests for ListApiKeys with any type of body
func NewListApiKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/api-keys/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateApiKeysRequest calls the generic UpdateApiKeys builder with application/json body
func NewUpdateApiKeysRequest(server string, body UpdateApiKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateApiKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateApiKeysRequestWithBody generates requests for UpdateApiKeys with any type of body
func NewUpdateApiKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/api-keys/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestPasswordResetRequest calls the generic RequestPasswordReset builder with application/json body
func NewRequestPasswordResetRequest(server string, body RequestPasswordResetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestPasswordResetRequestWithBody(server, "application/json", bodyReader)
}

// NewRequestPasswordResetRequestWithBody generates requests for RequestPasswordReset with any type of body
func NewRequestPasswordResetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/request-password-reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/auth/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListInstanceTypesRequest calls the generic ListInstanceTypes builder with application/json body
func NewListInstanceTypesRequest(server string, body ListInstanceTypesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListInstanceTypesRequestWithBody(server, "application/json", bodyReader)
}

// NewListInstanceTypesRequestWithBody generates requests for ListInstanceTypes with any type of body
func NewListInstanceTypesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/instance-types/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListInstancesRequest calls the generic ListInstances builder with application/json body
func NewListInstancesRequest(server string, body ListInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewListInstancesRequestWithBody generates requests for ListInstances with any type of body
func NewListInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/instances/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRentInstanceRequest calls the generic RentInstance builder with application/json body
func NewRentInstanceRequest(server string, body RentInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRentInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewRentInstanceRequestWithBody generates requests for RentInstance with any type of body
func NewRentInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/instances/rent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTerminateInstancesRequest calls the generic TerminateInstances builder with application/json body
func NewTerminateInstancesRequest(server string, body TerminateInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTerminateInstancesRequestWithBody(server, "application/json", bodyReader)
}

// NewTerminateInstancesRequestWithBody generates requests for TerminateInstances with any type of body
func NewTerminateInstancesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/instances/terminate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddNetworkRequest calls the generic AddNetwork builder with application/json body
func NewAddNetworkRequest(server string, body AddNetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddNetworkRequestWithBody(server, "application/json", bodyReader)
}

// NewAddNetworkRequestWithBody generates requests for AddNetwork with any type of body
func NewAddNetworkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/network/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNetworksRequest calls the generic ListNetworks builder with application/json body
func NewListNetworksRequest(server string, body ListNetworksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListNetworksRequestWithBody(server, "application/json", bodyReader)
}

// NewListNetworksRequestWithBody generates requests for ListNetworks with any type of body
func NewListNetworksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/network/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIpRangesRequest calls the generic ListIpRanges builder with application/json body
func NewListIpRangesRequest(server string, body ListIpRangesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListIpRangesRequestWithBody(server, "application/json", bodyReader)
}

// NewListIpRangesRequestWithBody generates requests for ListIpRanges with any type of body
func NewListIpRangesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/network/list-ranges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProvidersRequest calls the generic ListProviders builder with application/json body
func NewListProvidersRequest(server string, body ListProvidersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListProvidersRequestWithBody(server, "application/json", bodyReader)
}

// NewListProvidersRequestWithBody generates requests for ListProviders with any type of body
func NewListProvidersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/providers/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProviderNodesRequest calls the generic ListProviderNodes builder with application/json body
func NewListProviderNodesRequest(server string, body ListProviderNodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListProviderNodesRequestWithBody(server, "application/json", bodyReader)
}

// NewListProviderNodesRequestWithBody generates requests for ListProviderNodes with any type of body
func NewListProviderNodesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/providers/nodes/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRecipesRequest generates requests for ListRecipes
func NewListRecipesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/recipes/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReservationsRequest calls the generic ListReservations builder with application/json body
func NewListReservationsRequest(server string, body ListReservationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListReservationsRequestWithBody(server, "application/json", bodyReader)
}

// NewListReservationsRequestWithBody generates requests for ListReservations with any type of body
func NewListReservationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reservations/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListReservationTypesRequest generates requests for ListReservationTypes
func NewListReservationTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reservations/types/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkChargeForServiceRequest calls the generic BulkChargeForService builder with application/json body
func NewBulkChargeForServiceRequest(server string, body BulkChargeForServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkChargeForServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkChargeForServiceRequestWithBody generates requests for BulkChargeForService with any type of body
func NewBulkChargeForServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/services/bulk-charge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChargeForServiceRequest calls the generic ChargeForService builder with application/json body
func NewChargeForServiceRequest(server string, body ChargeForServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChargeForServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewChargeForServiceRequestWithBody generates requests for ChargeForService with any type of body
func NewChargeForServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/services/charge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddSshKeyRequest calls the generic AddSshKey builder with application/json body
func NewAddSshKeyRequest(server string, body AddSshKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddSshKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewAddSshKeyRequestWithBody generates requests for AddSshKey with any type of body
func NewAddSshKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ssh-keys/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSelectAndDeleteSshKeyRequest calls the generic SelectAndDeleteSshKey builder with application/json body
func NewSelectAndDeleteSshKeyRequest(server string, body SelectAndDeleteSshKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSelectAndDeleteSshKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewSelectAndDeleteSshKeyRequestWithBody generates requests for SelectAndDeleteSshKey with any type of body
func NewSelectAndDeleteSshKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ssh-keys/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSshKeysRequest generates requests for ListSshKeys
func NewListSshKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ssh-keys/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSshKeyRequest generates requests for DeleteSshKey
func NewDeleteSshKeyRequest(server string, sshKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ssh_key_id", runtime.ParamLocationPath, sshKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamRequest calls the generic CreateTeam builder with application/json body
func NewCreateTeamRequest(server string, body CreateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTeamRequestWithBody generates requests for CreateTeam with any type of body
func NewCreateTeamRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTeamsRequest generates requests for ListTeams
func NewListTeamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamRequest generates requests for GetTeam
func NewGetTeamRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTeamMemberRequest calls the generic AddTeamMember builder with application/json body
func NewAddTeamMemberRequest(server string, teamId string, body AddTeamMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTeamMemberRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewAddTeamMemberRequestWithBody generates requests for AddTeamMember with any type of body
func NewAddTeamMemberRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/members/add", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveTeamMemberRequest calls the generic RemoveTeamMember builder with application/json body
func NewRemoveTeamMemberRequest(server string, teamId string, body RemoveTeamMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveTeamMemberRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewRemoveTeamMemberRequestWithBody generates requests for RemoveTeamMember with any type of body
func NewRemoveTeamMemberRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/members/remove", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateTeamMembershipRequest calls the generic UpdateTeamMembership builder with application/json body
func NewUpdateTeamMembershipRequest(server string, teamId string, body UpdateTeamMembershipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamMembershipRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewUpdateTeamMembershipRequestWithBody generates requests for UpdateTeamMembership with any type of body
func NewUpdateTeamMembershipRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/teams/%s/members/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegisterUserRequest calls the generic RegisterUser builder with application/json body
func NewRegisterUserRequest(server string, body RegisterUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterUserRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterUserRequestWithBody generates requests for RegisterUser with any type of body
func NewRegisterUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountInfoWithResponse request
	GetAccountInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccountInfoResponse, error)

	// CreateExternalTransactionWithBodyWithResponse request with any body
	CreateExternalTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExternalTransactionResponse, error)

	CreateExternalTransactionWithResponse(ctx context.Context, body CreateExternalTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExternalTransactionResponse, error)

	// CreatePromoTransactionWithBodyWithResponse request with any body
	CreatePromoTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePromoTransactionResponse, error)

	CreatePromoTransactionWithResponse(ctx context.Context, body CreatePromoTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePromoTransactionResponse, error)

	// ListTransactionsWithResponse request
	ListTransactionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTransactionsResponse, error)

	// AddApiKeyWithBodyWithResponse request with any body
	AddApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddApiKeyResponse, error)

	AddApiKeyWithResponse(ctx context.Context, body AddApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddApiKeyResponse, error)

	// SelectAndDeleteApiKeysWithBodyWithResponse request with any body
	SelectAndDeleteApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectAndDeleteApiKeysResponse, error)

	SelectAndDeleteApiKeysWithResponse(ctx context.Context, body SelectAndDeleteApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectAndDeleteApiKeysResponse, error)

	// ListApiKeysWithBodyWithResponse request with any body
	ListApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error)

	ListApiKeysWithResponse(ctx context.Context, body ListApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error)

	// UpdateApiKeysWithBodyWithResponse request with any body
	UpdateApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApiKeysResponse, error)

	UpdateApiKeysWithResponse(ctx context.Context, body UpdateApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApiKeysResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// RequestPasswordResetWithBodyWithResponse request with any body
	RequestPasswordResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestPasswordResetResponse, error)

	RequestPasswordResetWithResponse(ctx context.Context, body RequestPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestPasswordResetResponse, error)

	// ResetPasswordWithBodyWithResponse request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// ListInstanceTypesWithBodyWithResponse request with any body
	ListInstanceTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInstanceTypesResponse, error)

	ListInstanceTypesWithResponse(ctx context.Context, body ListInstanceTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInstanceTypesResponse, error)

	// ListInstancesWithBodyWithResponse request with any body
	ListInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInstancesResponse, error)

	ListInstancesWithResponse(ctx context.Context, body ListInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInstancesResponse, error)

	// RentInstanceWithBodyWithResponse request with any body
	RentInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RentInstanceResponse, error)

	RentInstanceWithResponse(ctx context.Context, body RentInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*RentInstanceResponse, error)

	// TerminateInstancesWithBodyWithResponse request with any body
	TerminateInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TerminateInstancesResponse, error)

	TerminateInstancesWithResponse(ctx context.Context, body TerminateInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*TerminateInstancesResponse, error)

	// AddNetworkWithBodyWithResponse request with any body
	AddNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNetworkResponse, error)

	AddNetworkWithResponse(ctx context.Context, body AddNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNetworkResponse, error)

	// ListNetworksWithBodyWithResponse request with any body
	ListNetworksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListNetworksResponse, error)

	ListNetworksWithResponse(ctx context.Context, body ListNetworksJSONRequestBody, reqEditors ...RequestEditorFn) (*ListNetworksResponse, error)

	// ListIpRangesWithBodyWithResponse request with any body
	ListIpRangesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListIpRangesResponse, error)

	ListIpRangesWithResponse(ctx context.Context, body ListIpRangesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListIpRangesResponse, error)

	// ListProvidersWithBodyWithResponse request with any body
	ListProvidersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListProvidersResponse, error)

	ListProvidersWithResponse(ctx context.Context, body ListProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*ListProvidersResponse, error)

	// ListProviderNodesWithBodyWithResponse request with any body
	ListProviderNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListProviderNodesResponse, error)

	ListProviderNodesWithResponse(ctx context.Context, body ListProviderNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListProviderNodesResponse, error)

	// ListRecipesWithResponse request
	ListRecipesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRecipesResponse, error)

	// ListReservationsWithBodyWithResponse request with any body
	ListReservationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListReservationsResponse, error)

	ListReservationsWithResponse(ctx context.Context, body ListReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListReservationsResponse, error)

	// ListReservationTypesWithResponse request
	ListReservationTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListReservationTypesResponse, error)

	// BulkChargeForServiceWithBodyWithResponse request with any body
	BulkChargeForServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkChargeForServiceResponse, error)

	BulkChargeForServiceWithResponse(ctx context.Context, body BulkChargeForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkChargeForServiceResponse, error)

	// ChargeForServiceWithBodyWithResponse request with any body
	ChargeForServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChargeForServiceResponse, error)

	ChargeForServiceWithResponse(ctx context.Context, body ChargeForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*ChargeForServiceResponse, error)

	// AddSshKeyWithBodyWithResponse request with any body
	AddSshKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSshKeyResponse, error)

	AddSshKeyWithResponse(ctx context.Context, body AddSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSshKeyResponse, error)

	// SelectAndDeleteSshKeyWithBodyWithResponse request with any body
	SelectAndDeleteSshKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectAndDeleteSshKeyResponse, error)

	SelectAndDeleteSshKeyWithResponse(ctx context.Context, body SelectAndDeleteSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectAndDeleteSshKeyResponse, error)

	// ListSshKeysWithResponse request
	ListSshKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSshKeysResponse, error)

	// DeleteSshKeyWithResponse request
	DeleteSshKeyWithResponse(ctx context.Context, sshKeyId string, reqEditors ...RequestEditorFn) (*DeleteSshKeyResponse, error)

	// CreateTeamWithBodyWithResponse request with any body
	CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	// ListTeamsWithResponse request
	ListTeamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error)

	// GetTeamWithResponse request
	GetTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamResponse, error)

	// AddTeamMemberWithBodyWithResponse request with any body
	AddTeamMemberWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamMemberResponse, error)

	AddTeamMemberWithResponse(ctx context.Context, teamId string, body AddTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamMemberResponse, error)

	// RemoveTeamMemberWithBodyWithResponse request with any body
	RemoveTeamMemberWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTeamMemberResponse, error)

	RemoveTeamMemberWithResponse(ctx context.Context, teamId string, body RemoveTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTeamMemberResponse, error)

	// UpdateTeamMembershipWithBodyWithResponse request with any body
	UpdateTeamMembershipWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamMembershipResponse, error)

	UpdateTeamMembershipWithResponse(ctx context.Context, teamId string, body UpdateTeamMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamMembershipResponse, error)

	// RegisterUserWithBodyWithResponse request with any body
	RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)
}

type GetAccountInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountInfoProto
}

// Status returns HTTPResponse.Status
func (r GetAccountInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExternalTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateExternalTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExternalTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePromoTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePromoTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePromoTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionArrayProto
}

// Status returns HTTPResponse.Status
func (r ListTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddApiKeyResponseProto
}

// Status returns HTTPResponse.Status
func (r AddApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SelectAndDeleteApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteApiKeysResponseProto
}

// Status returns HTTPResponse.Status
func (r SelectAndDeleteApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SelectAndDeleteApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListApiKeysResponseProto
}

// Status returns HTTPResponse.Status
func (r ListApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *UpdateApiKeysResponseProto
}

// Status returns HTTPResponse.Status
func (r UpdateApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginUserResponseProto
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestPasswordResetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RequestPasswordResetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestPasswordResetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInstanceTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInstanceTypesResponseProto
}

// Status returns HTTPResponse.Status
func (r ListInstanceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInstanceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInstancesResponseProto
}

// Status returns HTTPResponse.Status
func (r ListInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RentInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RentInstanceResponseProto
}

// Status returns HTTPResponse.Status
func (r RentInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RentInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerminateInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TerminateInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerminateInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddNetworkResponseProto
}

// Status returns HTTPResponse.Status
func (r AddNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNetworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNetworksResponseProto
}

// Status returns HTTPResponse.Status
func (r ListNetworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIpRangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIpRangesResponseProto
}

// Status returns HTTPResponse.Status
func (r ListIpRangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIpRangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ListProvidersResponseProto
}

// Status returns HTTPResponse.Status
func (r ListProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProviderNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ListProviderNodesResponseProto
}

// Status returns HTTPResponse.Status
func (r ListProviderNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProviderNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecipesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRecipesResponseProto
}

// Status returns HTTPResponse.Status
func (r ListRecipesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecipesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ListReservationsResponseProto
}

// Status returns HTTPResponse.Status
func (r ListReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReservationTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListReservationTypesResponseProto
}

// Status returns HTTPResponse.Status
func (r ListReservationTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReservationTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkChargeForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BulkServiceChargeResponseProto
}

// Status returns HTTPResponse.Status
func (r BulkChargeForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkChargeForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChargeForServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceChargeResponseProto
}

// Status returns HTTPResponse.Status
func (r ChargeForServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChargeForServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GenerateSshKeyResponseProto
}

// Status returns HTTPResponse.Status
func (r AddSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SelectAndDeleteSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SelectAndDeleteSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SelectAndDeleteSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSshKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSshKeysResponseProto
}

// Status returns HTTPResponse.Status
func (r ListSshKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSshKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateTeamResponseProto
}

// Status returns HTTPResponse.Status
func (r CreateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTeamsResponseProto
}

// Status returns HTTPResponse.Status
func (r ListTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamResponseProto
}

// Status returns HTTPResponse.Status
func (r GetTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTeamMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamMemberResponseProto
}

// Status returns HTTPResponse.Status
func (r AddTeamMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTeamMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTeamMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamMemberResponseProto
}

// Status returns HTTPResponse.Status
func (r RemoveTeamMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTeamMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateTeamMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RegisterUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountInfoWithResponse request returning *GetAccountInfoResponse
func (c *ClientWithResponses) GetAccountInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccountInfoResponse, error) {
	rsp, err := c.GetAccountInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountInfoResponse(rsp)
}

// CreateExternalTransactionWithBodyWithResponse request with arbitrary body returning *CreateExternalTransactionResponse
func (c *ClientWithResponses) CreateExternalTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExternalTransactionResponse, error) {
	rsp, err := c.CreateExternalTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExternalTransactionResponse(rsp)
}

func (c *ClientWithResponses) CreateExternalTransactionWithResponse(ctx context.Context, body CreateExternalTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExternalTransactionResponse, error) {
	rsp, err := c.CreateExternalTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExternalTransactionResponse(rsp)
}

// CreatePromoTransactionWithBodyWithResponse request with arbitrary body returning *CreatePromoTransactionResponse
func (c *ClientWithResponses) CreatePromoTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePromoTransactionResponse, error) {
	rsp, err := c.CreatePromoTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePromoTransactionResponse(rsp)
}

func (c *ClientWithResponses) CreatePromoTransactionWithResponse(ctx context.Context, body CreatePromoTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePromoTransactionResponse, error) {
	rsp, err := c.CreatePromoTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePromoTransactionResponse(rsp)
}

// ListTransactionsWithResponse request returning *ListTransactionsResponse
func (c *ClientWithResponses) ListTransactionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTransactionsResponse, error) {
	rsp, err := c.ListTransactions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionsResponse(rsp)
}

// AddApiKeyWithBodyWithResponse request with arbitrary body returning *AddApiKeyResponse
func (c *ClientWithResponses) AddApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddApiKeyResponse, error) {
	rsp, err := c.AddApiKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddApiKeyResponse(rsp)
}

func (c *ClientWithResponses) AddApiKeyWithResponse(ctx context.Context, body AddApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddApiKeyResponse, error) {
	rsp, err := c.AddApiKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddApiKeyResponse(rsp)
}

// SelectAndDeleteApiKeysWithBodyWithResponse request with arbitrary body returning *SelectAndDeleteApiKeysResponse
func (c *ClientWithResponses) SelectAndDeleteApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectAndDeleteApiKeysResponse, error) {
	rsp, err := c.SelectAndDeleteApiKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectAndDeleteApiKeysResponse(rsp)
}

func (c *ClientWithResponses) SelectAndDeleteApiKeysWithResponse(ctx context.Context, body SelectAndDeleteApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectAndDeleteApiKeysResponse, error) {
	rsp, err := c.SelectAndDeleteApiKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectAndDeleteApiKeysResponse(rsp)
}

// ListApiKeysWithBodyWithResponse request with arbitrary body returning *ListApiKeysResponse
func (c *ClientWithResponses) ListApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error) {
	rsp, err := c.ListApiKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysResponse(rsp)
}

func (c *ClientWithResponses) ListApiKeysWithResponse(ctx context.Context, body ListApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error) {
	rsp, err := c.ListApiKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysResponse(rsp)
}

// UpdateApiKeysWithBodyWithResponse request with arbitrary body returning *UpdateApiKeysResponse
func (c *ClientWithResponses) UpdateApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApiKeysResponse, error) {
	rsp, err := c.UpdateApiKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApiKeysResponse(rsp)
}

func (c *ClientWithResponses) UpdateApiKeysWithResponse(ctx context.Context, body UpdateApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApiKeysResponse, error) {
	rsp, err := c.UpdateApiKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApiKeysResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// RequestPasswordResetWithBodyWithResponse request with arbitrary body returning *RequestPasswordResetResponse
func (c *ClientWithResponses) RequestPasswordResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestPasswordResetResponse, error) {
	rsp, err := c.RequestPasswordResetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestPasswordResetResponse(rsp)
}

func (c *ClientWithResponses) RequestPasswordResetWithResponse(ctx context.Context, body RequestPasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestPasswordResetResponse, error) {
	rsp, err := c.RequestPasswordReset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestPasswordResetResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// ListInstanceTypesWithBodyWithResponse request with arbitrary body returning *ListInstanceTypesResponse
func (c *ClientWithResponses) ListInstanceTypesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInstanceTypesResponse, error) {
	rsp, err := c.ListInstanceTypesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstanceTypesResponse(rsp)
}

func (c *ClientWithResponses) ListInstanceTypesWithResponse(ctx context.Context, body ListInstanceTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInstanceTypesResponse, error) {
	rsp, err := c.ListInstanceTypes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstanceTypesResponse(rsp)
}

// ListInstancesWithBodyWithResponse request with arbitrary body returning *ListInstancesResponse
func (c *ClientWithResponses) ListInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInstancesResponse, error) {
	rsp, err := c.ListInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstancesResponse(rsp)
}

func (c *ClientWithResponses) ListInstancesWithResponse(ctx context.Context, body ListInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInstancesResponse, error) {
	rsp, err := c.ListInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstancesResponse(rsp)
}

// RentInstanceWithBodyWithResponse request with arbitrary body returning *RentInstanceResponse
func (c *ClientWithResponses) RentInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RentInstanceResponse, error) {
	rsp, err := c.RentInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRentInstanceResponse(rsp)
}

func (c *ClientWithResponses) RentInstanceWithResponse(ctx context.Context, body RentInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*RentInstanceResponse, error) {
	rsp, err := c.RentInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRentInstanceResponse(rsp)
}

// TerminateInstancesWithBodyWithResponse request with arbitrary body returning *TerminateInstancesResponse
func (c *ClientWithResponses) TerminateInstancesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TerminateInstancesResponse, error) {
	rsp, err := c.TerminateInstancesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateInstancesResponse(rsp)
}

func (c *ClientWithResponses) TerminateInstancesWithResponse(ctx context.Context, body TerminateInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*TerminateInstancesResponse, error) {
	rsp, err := c.TerminateInstances(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTerminateInstancesResponse(rsp)
}

// AddNetworkWithBodyWithResponse request with arbitrary body returning *AddNetworkResponse
func (c *ClientWithResponses) AddNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNetworkResponse, error) {
	rsp, err := c.AddNetworkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNetworkResponse(rsp)
}

func (c *ClientWithResponses) AddNetworkWithResponse(ctx context.Context, body AddNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNetworkResponse, error) {
	rsp, err := c.AddNetwork(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNetworkResponse(rsp)
}

// ListNetworksWithBodyWithResponse request with arbitrary body returning *ListNetworksResponse
func (c *ClientWithResponses) ListNetworksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListNetworksResponse, error) {
	rsp, err := c.ListNetworksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNetworksResponse(rsp)
}

func (c *ClientWithResponses) ListNetworksWithResponse(ctx context.Context, body ListNetworksJSONRequestBody, reqEditors ...RequestEditorFn) (*ListNetworksResponse, error) {
	rsp, err := c.ListNetworks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNetworksResponse(rsp)
}

// ListIpRangesWithBodyWithResponse request with arbitrary body returning *ListIpRangesResponse
func (c *ClientWithResponses) ListIpRangesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListIpRangesResponse, error) {
	rsp, err := c.ListIpRangesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIpRangesResponse(rsp)
}

func (c *ClientWithResponses) ListIpRangesWithResponse(ctx context.Context, body ListIpRangesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListIpRangesResponse, error) {
	rsp, err := c.ListIpRanges(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIpRangesResponse(rsp)
}

// ListProvidersWithBodyWithResponse request with arbitrary body returning *ListProvidersResponse
func (c *ClientWithResponses) ListProvidersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListProvidersResponse, error) {
	rsp, err := c.ListProvidersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProvidersResponse(rsp)
}

func (c *ClientWithResponses) ListProvidersWithResponse(ctx context.Context, body ListProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*ListProvidersResponse, error) {
	rsp, err := c.ListProviders(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProvidersResponse(rsp)
}

// ListProviderNodesWithBodyWithResponse request with arbitrary body returning *ListProviderNodesResponse
func (c *ClientWithResponses) ListProviderNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListProviderNodesResponse, error) {
	rsp, err := c.ListProviderNodesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProviderNodesResponse(rsp)
}

func (c *ClientWithResponses) ListProviderNodesWithResponse(ctx context.Context, body ListProviderNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListProviderNodesResponse, error) {
	rsp, err := c.ListProviderNodes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProviderNodesResponse(rsp)
}

// ListRecipesWithResponse request returning *ListRecipesResponse
func (c *ClientWithResponses) ListRecipesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRecipesResponse, error) {
	rsp, err := c.ListRecipes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRecipesResponse(rsp)
}

// ListReservationsWithBodyWithResponse request with arbitrary body returning *ListReservationsResponse
func (c *ClientWithResponses) ListReservationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListReservationsResponse, error) {
	rsp, err := c.ListReservationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReservationsResponse(rsp)
}

func (c *ClientWithResponses) ListReservationsWithResponse(ctx context.Context, body ListReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListReservationsResponse, error) {
	rsp, err := c.ListReservations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReservationsResponse(rsp)
}

// ListReservationTypesWithResponse request returning *ListReservationTypesResponse
func (c *ClientWithResponses) ListReservationTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListReservationTypesResponse, error) {
	rsp, err := c.ListReservationTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReservationTypesResponse(rsp)
}

// BulkChargeForServiceWithBodyWithResponse request with arbitrary body returning *BulkChargeForServiceResponse
func (c *ClientWithResponses) BulkChargeForServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkChargeForServiceResponse, error) {
	rsp, err := c.BulkChargeForServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkChargeForServiceResponse(rsp)
}

func (c *ClientWithResponses) BulkChargeForServiceWithResponse(ctx context.Context, body BulkChargeForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkChargeForServiceResponse, error) {
	rsp, err := c.BulkChargeForService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkChargeForServiceResponse(rsp)
}

// ChargeForServiceWithBodyWithResponse request with arbitrary body returning *ChargeForServiceResponse
func (c *ClientWithResponses) ChargeForServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChargeForServiceResponse, error) {
	rsp, err := c.ChargeForServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChargeForServiceResponse(rsp)
}

func (c *ClientWithResponses) ChargeForServiceWithResponse(ctx context.Context, body ChargeForServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*ChargeForServiceResponse, error) {
	rsp, err := c.ChargeForService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChargeForServiceResponse(rsp)
}

// AddSshKeyWithBodyWithResponse request with arbitrary body returning *AddSshKeyResponse
func (c *ClientWithResponses) AddSshKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSshKeyResponse, error) {
	rsp, err := c.AddSshKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSshKeyResponse(rsp)
}

func (c *ClientWithResponses) AddSshKeyWithResponse(ctx context.Context, body AddSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSshKeyResponse, error) {
	rsp, err := c.AddSshKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSshKeyResponse(rsp)
}

// SelectAndDeleteSshKeyWithBodyWithResponse request with arbitrary body returning *SelectAndDeleteSshKeyResponse
func (c *ClientWithResponses) SelectAndDeleteSshKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SelectAndDeleteSshKeyResponse, error) {
	rsp, err := c.SelectAndDeleteSshKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectAndDeleteSshKeyResponse(rsp)
}

func (c *ClientWithResponses) SelectAndDeleteSshKeyWithResponse(ctx context.Context, body SelectAndDeleteSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*SelectAndDeleteSshKeyResponse, error) {
	rsp, err := c.SelectAndDeleteSshKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSelectAndDeleteSshKeyResponse(rsp)
}

// ListSshKeysWithResponse request returning *ListSshKeysResponse
func (c *ClientWithResponses) ListSshKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSshKeysResponse, error) {
	rsp, err := c.ListSshKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSshKeysResponse(rsp)
}

// DeleteSshKeyWithResponse request returning *DeleteSshKeyResponse
func (c *ClientWithResponses) DeleteSshKeyWithResponse(ctx context.Context, sshKeyId string, reqEditors ...RequestEditorFn) (*DeleteSshKeyResponse, error) {
	rsp, err := c.DeleteSshKey(ctx, sshKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSshKeyResponse(rsp)
}

// CreateTeamWithBodyWithResponse request with arbitrary body returning *CreateTeamResponse
func (c *ClientWithResponses) CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeamWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

func (c *ClientWithResponses) CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeam(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

// ListTeamsWithResponse request returning *ListTeamsResponse
func (c *ClientWithResponses) ListTeamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error) {
	rsp, err := c.ListTeams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamsResponse(rsp)
}

// GetTeamWithResponse request returning *GetTeamResponse
func (c *ClientWithResponses) GetTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamResponse, error) {
	rsp, err := c.GetTeam(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamResponse(rsp)
}

// AddTeamMemberWithBodyWithResponse request with arbitrary body returning *AddTeamMemberResponse
func (c *ClientWithResponses) AddTeamMemberWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTeamMemberResponse, error) {
	rsp, err := c.AddTeamMemberWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamMemberResponse(rsp)
}

func (c *ClientWithResponses) AddTeamMemberWithResponse(ctx context.Context, teamId string, body AddTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTeamMemberResponse, error) {
	rsp, err := c.AddTeamMember(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTeamMemberResponse(rsp)
}

// RemoveTeamMemberWithBodyWithResponse request with arbitrary body returning *RemoveTeamMemberResponse
func (c *ClientWithResponses) RemoveTeamMemberWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTeamMemberResponse, error) {
	rsp, err := c.RemoveTeamMemberWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTeamMemberResponse(rsp)
}

func (c *ClientWithResponses) RemoveTeamMemberWithResponse(ctx context.Context, teamId string, body RemoveTeamMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTeamMemberResponse, error) {
	rsp, err := c.RemoveTeamMember(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTeamMemberResponse(rsp)
}

// UpdateTeamMembershipWithBodyWithResponse request with arbitrary body returning *UpdateTeamMembershipResponse
func (c *ClientWithResponses) UpdateTeamMembershipWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamMembershipResponse, error) {
	rsp, err := c.UpdateTeamMembershipWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamMembershipResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamMembershipWithResponse(ctx context.Context, teamId string, body UpdateTeamMembershipJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamMembershipResponse, error) {
	rsp, err := c.UpdateTeamMembership(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamMembershipResponse(rsp)
}

// RegisterUserWithBodyWithResponse request with arbitrary body returning *RegisterUserResponse
func (c *ClientWithResponses) RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

func (c *ClientWithResponses) RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

// ParseGetAccountInfoResponse parses an HTTP response from a GetAccountInfoWithResponse call
func ParseGetAccountInfoResponse(rsp *http.Response) (*GetAccountInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountInfoProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateExternalTransactionResponse parses an HTTP response from a CreateExternalTransactionWithResponse call
func ParseCreateExternalTransactionResponse(rsp *http.Response) (*CreateExternalTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExternalTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePromoTransactionResponse parses an HTTP response from a CreatePromoTransactionWithResponse call
func ParseCreatePromoTransactionResponse(rsp *http.Response) (*CreatePromoTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePromoTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTransactionsResponse parses an HTTP response from a ListTransactionsWithResponse call
func ParseListTransactionsResponse(rsp *http.Response) (*ListTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionArrayProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddApiKeyResponse parses an HTTP response from a AddApiKeyWithResponse call
func ParseAddApiKeyResponse(rsp *http.Response) (*AddApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddApiKeyResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSelectAndDeleteApiKeysResponse parses an HTTP response from a SelectAndDeleteApiKeysWithResponse call
func ParseSelectAndDeleteApiKeysResponse(rsp *http.Response) (*SelectAndDeleteApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SelectAndDeleteApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteApiKeysResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListApiKeysResponse parses an HTTP response from a ListApiKeysWithResponse call
func ParseListApiKeysResponse(rsp *http.Response) (*ListApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListApiKeysResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateApiKeysResponse parses an HTTP response from a UpdateApiKeysWithResponse call
func ParseUpdateApiKeysResponse(rsp *http.Response) (*UpdateApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest UpdateApiKeysResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginUserResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRequestPasswordResetResponse parses an HTTP response from a RequestPasswordResetWithResponse call
func ParseRequestPasswordResetResponse(rsp *http.Response) (*RequestPasswordResetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestPasswordResetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListInstanceTypesResponse parses an HTTP response from a ListInstanceTypesWithResponse call
func ParseListInstanceTypesResponse(rsp *http.Response) (*ListInstanceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInstanceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInstanceTypesResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInstancesResponse parses an HTTP response from a ListInstancesWithResponse call
func ParseListInstancesResponse(rsp *http.Response) (*ListInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInstancesResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRentInstanceResponse parses an HTTP response from a RentInstanceWithResponse call
func ParseRentInstanceResponse(rsp *http.Response) (*RentInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RentInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RentInstanceResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTerminateInstancesResponse parses an HTTP response from a TerminateInstancesWithResponse call
func ParseTerminateInstancesResponse(rsp *http.Response) (*TerminateInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TerminateInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddNetworkResponse parses an HTTP response from a AddNetworkWithResponse call
func ParseAddNetworkResponse(rsp *http.Response) (*AddNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddNetworkResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListNetworksResponse parses an HTTP response from a ListNetworksWithResponse call
func ParseListNetworksResponse(rsp *http.Response) (*ListNetworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNetworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNetworksResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIpRangesResponse parses an HTTP response from a ListIpRangesWithResponse call
func ParseListIpRangesResponse(rsp *http.Response) (*ListIpRangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIpRangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIpRangesResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListProvidersResponse parses an HTTP response from a ListProvidersWithResponse call
func ParseListProvidersResponse(rsp *http.Response) (*ListProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ListProvidersResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListProviderNodesResponse parses an HTTP response from a ListProviderNodesWithResponse call
func ParseListProviderNodesResponse(rsp *http.Response) (*ListProviderNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProviderNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ListProviderNodesResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListRecipesResponse parses an HTTP response from a ListRecipesWithResponse call
func ParseListRecipesResponse(rsp *http.Response) (*ListRecipesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecipesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRecipesResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListReservationsResponse parses an HTTP response from a ListReservationsWithResponse call
func ParseListReservationsResponse(rsp *http.Response) (*ListReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ListReservationsResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListReservationTypesResponse parses an HTTP response from a ListReservationTypesWithResponse call
func ParseListReservationTypesResponse(rsp *http.Response) (*ListReservationTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReservationTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListReservationTypesResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkChargeForServiceResponse parses an HTTP response from a BulkChargeForServiceWithResponse call
func ParseBulkChargeForServiceResponse(rsp *http.Response) (*BulkChargeForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkChargeForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BulkServiceChargeResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseChargeForServiceResponse parses an HTTP response from a ChargeForServiceWithResponse call
func ParseChargeForServiceResponse(rsp *http.Response) (*ChargeForServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChargeForServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceChargeResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseAddSshKeyResponse parses an HTTP response from a AddSshKeyWithResponse call
func ParseAddSshKeyResponse(rsp *http.Response) (*AddSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GenerateSshKeyResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSelectAndDeleteSshKeyResponse parses an HTTP response from a SelectAndDeleteSshKeyWithResponse call
func ParseSelectAndDeleteSshKeyResponse(rsp *http.Response) (*SelectAndDeleteSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SelectAndDeleteSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListSshKeysResponse parses an HTTP response from a ListSshKeysWithResponse call
func ParseListSshKeysResponse(rsp *http.Response) (*ListSshKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSshKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSshKeysResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSshKeyResponse parses an HTTP response from a DeleteSshKeyWithResponse call
func ParseDeleteSshKeyResponse(rsp *http.Response) (*DeleteSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTeamResponse parses an HTTP response from a CreateTeamWithResponse call
func ParseCreateTeamResponse(rsp *http.Response) (*CreateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateTeamResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListTeamsResponse parses an HTTP response from a ListTeamsWithResponse call
func ParseListTeamsResponse(rsp *http.Response) (*ListTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTeamsResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTeamResponse parses an HTTP response from a GetTeamWithResponse call
func ParseGetTeamResponse(rsp *http.Response) (*GetTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddTeamMemberResponse parses an HTTP response from a AddTeamMemberWithResponse call
func ParseAddTeamMemberResponse(rsp *http.Response) (*AddTeamMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTeamMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamMemberResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveTeamMemberResponse parses an HTTP response from a RemoveTeamMemberWithResponse call
func ParseRemoveTeamMemberResponse(rsp *http.Response) (*RemoveTeamMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTeamMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamMemberResponseProto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTeamMembershipResponse parses an HTTP response from a UpdateTeamMembershipWithResponse call
func ParseUpdateTeamMembershipResponse(rsp *http.Response) (*UpdateTeamMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRegisterUserResponse parses an HTTP response from a RegisterUserWithResponse call
func ParseRegisterUserResponse(rsp *http.Response) (*RegisterUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
